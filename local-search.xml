<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RabbitMQ必知会</title>
    <link href="/2024/01/05/RabbitMQ%E5%BF%85%E7%9F%A5%E4%BC%9A/"/>
    <url>/2024/01/05/RabbitMQ%E5%BF%85%E7%9F%A5%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="https://cloud.tencent.com/developer/article/1816305">https://cloud.tencent.com/developer/article/1816305</a></li><li><a href="https://www.tizi365.com/course/2.html">https://www.tizi365.com/course/2.html</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ和Kafka对比</title>
    <link href="/2024/01/04/RabbitMQ%E5%92%8CKafka%E5%AF%B9%E6%AF%94/"/>
    <url>/2024/01/04/RabbitMQ%E5%92%8CKafka%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h2 id="架构差异"><a href="#架构差异" class="headerlink" title="架构差异"></a>架构差异</h2><p>RabbitMQ 和 Apache Kafka 均允许生产者向使用者发送消息。<em>生产者</em>是发布信息的应用程序，而<em>使用者</em>是订阅和处理信息的应用程序。</p><p>在 RabbitMQ 和 Kafka 中，生产者和使用者的互动方式有所不同。在 RabbitMQ 中，生产者发送并监控消息是否到达目标使用者。另一方面，无论使用者是否检索消息，Kafka 生产者都会向队列发布消息。</p><p>可以将 RabbitMQ 视为接收邮件并将其传输给预定收件人的邮局。与此同时，Kafka 类似于图书馆，它在书架上整理生产者发布的不同类型消息。然后，使用者读取相应书架上的消息，并记住他们所读取的内容。 </p><h3 id="RabbitMQ-架构方法"><a href="#RabbitMQ-架构方法" class="headerlink" title="RabbitMQ 架构方法"></a><strong>RabbitMQ 架构方法</strong></h3><p>RabbitMQ 代理允许使用以下组件进行低延迟和复杂的消息分配：</p><ul><li><em>交换机</em>接收来自生产者的消息并确定应将它们路由到何处</li><li><em>队列</em>是接收来自交换机的消息并将其发送给使用者的存储空间</li><li><em>绑定</em>是连接交换机和代理的路径</li></ul><p>在 RabbitMQ 中，<em>路由密钥</em>是一种消息属性，用于将消息从交换机路由到特定队列。当生产者向交换机发送消息时，它会将路由密钥作为消息的一部分包含在内。然后，交换机使用此路由密钥来确定消息应传输到哪个队列。</p><h3 id="Kafka-架构方法"><a href="#Kafka-架构方法" class="headerlink" title="Kafka 架构方法"></a><strong>Kafka 架构方法</strong></h3><p>Kafka 集群通过更复杂的架构提供高吞吐量流事件处理。以下是 Kafka 的一些关键组件：</p><ul><li><em>Kafka 代理</em>是 Kafka 服务器，允许生产者将数据流式传输给使用者。 Kafka 代理包含主题及其相应的分区。 </li><li><em>主题</em>是在 Kafka 代理中对相似数据进行分组的数据存储。 </li><li><em>分区</em>是使用者所订阅主题中较小的数据存储空间。 </li><li>ZooKeeper 是特殊的软件，用于管理 Kafka 集群和分区以提供容错流式处理。ZooKeeper 最近被 Apache Kafka Raft（KRaft）协议所取代。</li></ul><p>Kafka 中的生产者为每条消息分配一个消息密钥。然后，Kafka 代理将消息存储在该特定主题的前导分区中。KRaft 协议使用共识算法来确定前导分区。 </p><h2 id="处理消息方式"><a href="#处理消息方式" class="headerlink" title="处理消息方式"></a>处理消息方式</h2><p>RabbitMQ 和 Apache Kafka 以不同的方式将数据从生产者转移到使用者。RabbitMQ 是通用消息代理，它优先考虑端到端消息传输。Kafka 是分布式事件流式处理平台，支持持续大数据的实时交换。</p><p>RabbitMQ 和 Kafka 针对不同的使用案例而设计，因此它们处理消息的方式有所不同。 接下来，我们讨论一些具体的差异。</p><h3 id="消息使用"><a href="#消息使用" class="headerlink" title="消息使用"></a><strong>消息使用</strong></h3><p>在 RabbitMQ 中，代理确保使用者收到消息。使用者应用程序扮演被动角色，等待 RabbitMQ 代理将消息推送到队列中。例如，银行应用程序可能会等待来自中央交易处理软件的短信提醒。</p><p>然而，Kafka 使用者更积极地读取和跟踪信息。当消息加入实体日志文件时，Kafka 使用者会跟踪他们读取的最后一条消息，并相应地更新偏移跟踪器。偏移跟踪器是读取消息后递增的计数器。使用 Kafka，生产者并不知道使用者会检索消息。 </p><h3 id="消息优先级"><a href="#消息优先级" class="headerlink" title="消息优先级"></a><strong>消息优先级</strong></h3><p>RabbitMQ 代理允许生产者软件使用优先队列升级某些消息。代理不是按<em>先入先出</em>的顺序发送消息，而是先处理更高优先级的消息，然后再处理普通消息。例如，零售应用程序可能每小时将销售交易排队一次。但是，如果系统管理员发出优先的备份数据库消息，则代理会立即发送该消息。</p><p>与 RabbitMQ 不同，Apache Kafka 不支持优先级队列。将所有消息分配到各自的分区时，该代理平等对待这些消息。 </p><h3 id="消息排序"><a href="#消息排序" class="headerlink" title="消息排序"></a><strong>消息排序</strong></h3><p>RabbitMQ 按特定顺序发送消息和对其进行排队。除非有更高优先级的消息排入系统，否则使用者会按照消息的发送顺序接收消息。</p><p>同时，Kafka 使用主题和分区对消息进行排队。当生产者发送消息时，消息会进入特定的主题和分区。由于 Kafka 不支持直接的生产者与使用者交换，因此使用者以不同的顺序从分区中拉取消息。 </p><h3 id="消息删除"><a href="#消息删除" class="headerlink" title="消息删除"></a><strong>消息删除</strong></h3><p>RabbitMQ 代理将消息路由到目标队列。读取后，使用者向代理发送确认（ACK）回复，然后代理将消息从队列中删除。</p><p>与 RabbitMQ 不同，Apache Kafka 将消息附加到日志文件中，该日志文件将一直留存到其保留期到期。这样，使用者可以在规定的时间内随时重新处理流式传输的数据。</p><h2 id="Kafka-和-RabbitMQ功能对比"><a href="#Kafka-和-RabbitMQ功能对比" class="headerlink" title="Kafka 和 RabbitMQ功能对比"></a>Kafka 和 RabbitMQ功能对比</h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>RabbitMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td><strong>吞吐量</strong></td><td>低</td><td>高</td></tr><tr><td><strong>有序性</strong></td><td>全局有序性</td><td>分区有序性</td></tr><tr><td><strong>消息可靠性</strong></td><td>多策略组合</td><td>消息持久化</td></tr><tr><td><strong>流处理</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>时效性</strong></td><td>高</td><td>中</td></tr><tr><td><strong>运维便捷度</strong></td><td>高</td><td>中</td></tr><tr><td><strong>系统依赖</strong></td><td>无</td><td>zookeeper</td></tr><tr><td><strong>Web监控</strong></td><td>自带</td><td>第三方</td></tr><tr><td><strong>优先级队列</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>死信</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>客户端支持</strong></td><td>支持多种语言</td><td></td></tr><tr><td><strong>社区生态</strong></td><td>好</td><td></td></tr><tr><td><strong>安全机制</strong></td><td>（TLS&#x2F;SSL、SASL）身份认证和（读写）权限控制</td><td></td></tr><tr><td><strong>消息回溯</strong></td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h3><p>Kafka的诞生的是处理高并发日志的，吞吐量比较高，每秒请求数达到数十万量级</p><p>RabbitMQ每秒请求数则为万级别，有测试报告指出Kafka是RabbitMQ的10倍以上性能。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a><strong>有序性</strong></h3><p>RabbitMQ理论上是全局有序性的，但是由于【发后既忘】+【自动确认】机制的原因，如果在同个队列的多个消费者做相同的业务处理时，他们的各自的执行任务无法保证有序完成。如果确保100%有序可以使用【非自动确认】，但会影响消费性能。</p><p>Kafka支持分区有序性，如果对有序性有严格要求可以设置单个Partition，可是单个Partition并发性比较低，因此在多个Partition情况下可以根据业务指定key把相关的消息路由到同一个Partition，例如相同UserId行为信息可以到Partition 1进行处理。</p><h3 id="Kafka为什么快"><a href="#Kafka为什么快" class="headerlink" title="Kafka为什么快"></a><strong>Kafka为什么快</strong></h3><p>关键核心技术点：</p><ul><li>异步批量处理</li><li>磁盘顺序读写</li><li>操作系统PageCache缓存数据</li><li>零拷贝加速消费</li></ul><p>Kafka的诞生就是为了高并发日志处理的，那么在他整个机制里使用了很多批量、异步、缓存。例如生产者客户端，他会积累一定量（条数、大小）的消息，再批量的发给kafka broker，如果在这段时间客户端服务挂了，就等于消息丢失了。当broker接受到了消息后，还有一堆骚操作-异步刷盘，也就是生产者发送给broker之后他是记录在缓存的，每隔一段时间才会持久化到磁盘，假如这段真空期broker挂了，消息也是丢了。</p><h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2><table><thead><tr><th></th><th>RabbitMQ</th><th>kafka</th></tr></thead><tbody><tr><td>优点</td><td>1、稳定可靠，数据不会丢失。<br>2、管理界面较丰富</td><td>1、这些方面表现很好：高吞吐、低延迟、高可用、集群热扩展、集群容错<br>2、producer端提供缓存、压缩功能，可节省性能，提高效率。<br>3、提供顺序消费能力<br>4、生态完善，在大数据处理方面有大量配套的设施。</td></tr><tr><td>缺点</td><td>1、在高吞吐量、高可用上较其他两者有所不如。<br><br>2. erlang 语言难度较大。基本只能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护<br>3、不支持事务<br><br>4、消息吞吐能力较差，消息堆积时，性能会明显降低</td><td>1、消息容易丢失，适合做日志系统，不适合做数据系统。<br><br>2、消费集群数目受到分区数目的限制。<br>2、单机topic多时，性能会明显降低。单机超过64个队列&#x2F;分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长<br>3、不支持事务<br><br>4、支持消息顺序，但是一台代理宕机后，就会产生消息乱序；<br><br>5、消费失败不支持重试</td></tr></tbody></table><h2 id="如何选型"><a href="#如何选型" class="headerlink" title="如何选型"></a>如何选型</h2><p>RabbitMQ 和 Kafka 不是相互竞争的消息代理。两者都旨在支持不同使用案例中的数据交换，分别有其适用场景。下面有一些场景和选型建议：</p><ol><li><p><strong>事件流重放</strong></p><p>Kafka 适用于需要重新分析所接收数据的应用程序。可以在保留期内多次处理流式数据或收集日志文件进行分析。</p><p>使用 RabbitMQ 进行日志聚合更具挑战性，因为消息一旦使用就会被删除。解决方法是重放来自生产者的已存储消息。</p></li><li><p><strong>实时数据流式处理</strong></p><p>Kafka 以非常低的延迟流式传输消息，适用于实时分析流式数据。例如，可以将 Kafka 用作分布式监控服务，为在线事务处理实时发出提醒。</p></li><li><p><strong>复杂的路由架构</strong></p><p>RabbitMQ 为要求模糊或路由场景复杂的客户端提供灵活性。例如，可以将 RabbitMQ 设置为将数据路由到具有不同绑定和交换机的不同应用程序。</p></li><li><p><strong>有效的消息传输</strong></p><p>RabbitMQ 采用推送模型，这意味着生产者知悉客户端应用程序是否使用消息。该方法适用于在交换和分析数据时必须遵守特定顺序和传输保证的应用程序。</p></li></ol><p><strong>另外选型也可以从前面RabbitMQ 和 Kafka 的功能对比和优缺点对比上入手，根据我们实际业务需要做选择。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.51cto.com/knifeedge/5011115">https://blog.51cto.com/knifeedge/5011115</a></li><li><a href="https://aws.amazon.com/cn/compare/the-difference-between-rabbitmq-and-kafka/">https://aws.amazon.com/cn/compare/the-difference-between-rabbitmq-and-kafka/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈RPC</title>
    <link href="/2024/01/04/%E6%B5%85%E8%B0%88RPC/"/>
    <url>/2024/01/04/%E6%B5%85%E8%B0%88RPC/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>RPC（Remote Procedure Call）远程过程调用协议是一个用于建立适当框架的协议。从本质上讲，它使一台机器上的程序能够调用另一台机器上的子程序，而不会意识到它是远程的。</p><p>RPC 是一种软件通信协议，一个程序可以用来向位于网络上另一台计算机的程序请求服务，而不必了解网络的细节。RPC 被用来像本地系统一样调用远程系统上的其他进程。过程调用有时也被称为函数调用或子程序调用。</p><p>RPC要解决的问题：</p><ol><li>解决分布式系统中，服务之间的调用问题。</li><li>远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。</li></ol><h2 id="为什么要使用RPC"><a href="#为什么要使用RPC" class="headerlink" title="为什么要使用RPC"></a>为什么要使用RPC</h2><p>Socket 和 HTTP 编程使用消息传递范式。客户端向服务器发送一个消息，而服务器通常会发送一个消息回来。双方都负责以双方都能理解的格式创建消息，并从这些消息中读出数据。</p><p>然而，大多数独立的应用程序并没有那么多地使用消息传递技术。一般来说，首选的机制是函数（或方法或过程）的调用。在这种方式中，程序将调用一个带有参数列表的函数，并在完成函数调用后有一组返回值。这些值可能是函数值，或者如果地址被作为参数传递，那么这些地址的内容可能已经被改变。地址的内容可能已经被改变。</p><p>RPC 就是将这种编程方式引入网络世界的一种尝试。因此，客户端将进行在它看来是正常的过程调用。客户端会将其打包成网络消息并传送给服务器。服务器会将其解包，并在服务器端将其转回为过程调用。服务器端的过程调用。这个调用的结果将被打包，以便返回给客户端。</p><h2 id="RPC如何工作"><a href="#RPC如何工作" class="headerlink" title="RPC如何工作"></a>RPC如何工作</h2><p>具体步骤如下：</p><ol><li>服务消费者（client客户端）通过本地调用的方式调用服务。</li><li>客户端接收到请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体。</li><li>客户端找到远程的服务地址，并且将消息通过网络发送给服务端。</li><li>服务端收到消息后进行解码（反序列化操作）。</li><li>服务端根据解码结果调用本地的服务进行相关处理。</li><li>本地服务执行具体业务逻辑并将处理结果返回给服务端。</li><li>服务端将返回结果重新打包成消息（序列化）并通过网络发送至消费方。</li><li>客户端接收到消息，并进行解码（反序列化）。</li><li>服务消费方得到最终结果。</li></ol><p>设计到的技术：</p><ol><li>服务发现</li><li>服务注册</li><li>负载均衡</li><li>序列化</li><li>健康检查</li></ol><h2 id="RPC和REST的区别"><a href="#RPC和REST的区别" class="headerlink" title="RPC和REST的区别"></a>RPC和REST的区别</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>REST 是Representational State Transfer的简称，是一种软件架构风格，中文描述为表述性状态转移（是指某个瞬时状态的资源数据的快照，包括资源数据的内容、表述格式（XML、JSON）等信息）。这种风格的典型应用就是HTTP。</p><p>RPC 是 Remote Procedure Call 的缩写形式，中文描述为远程过程调用，用来屏蔽远程调用跟本地调用的区别，是解决应用间通信的一种方式。</p><p>RPC 可以基于TCP&#x2F;UDP,也可以基于HTTP协议进行传输。</p><p>REST 是目前最流行的一套互联网应用程序的API设计标准。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><p>使用方式不同</p><p>REST的HTTP接口只关注服务提供方，对于客户端怎么调用并不关心。接口只要保证有客户端调用时，返回对应的数据就可以了。</p><p>RPC则要求接口客户端和服务端要保持一致。</p><p>REST要求服务端定义好方法，客户端无需知晓具体方法，客户端发起HTTP请求获取资源，服务端获取请求后，根据URI通过一系列的路由定位到相关方法。</p><p>RPC需要提供好方法给客户端调用，客户端需要知晓服务端的具体接口、具体方法、然后通过动态代理，实现像调用本地方法一样调用远程方法。</p></li><li><p>面向对象不同</p><p>RPC，是面向方法的。可自定义协议，优化数据的传输。主要用于分布式系统之间，服务模块之间的通信。</p><p>REST，是面向资源的。更加注重接口的规范。通用性更强。</p></li><li><p>通信协议和序列化协议不同</p><p>通信协议上，REST是基于HTTP协议，而RPC可以基于TCP&#x2F;UDP,也可以基于HTTP协议进行传输。</p><p>常见的序列化协议有:json、xml、hession、protobuf、protoStuff、thrift、text、bytes等。</p><p>REST通常使用的是json和xml,而RPC的选择范围就比较广了，可以是json、hession、protobuf等。</p></li></ol><h2 id="RPC和REST的优缺点对比"><a href="#RPC和REST的优缺点对比" class="headerlink" title="RPC和REST的优缺点对比"></a>RPC和REST的优缺点对比</h2><table><thead><tr><th></th><th>RPC</th><th>REST</th></tr></thead><tbody><tr><td>优点</td><td>高效：RPC使用自定义的通信协议，可以减少报文传输量，提高传输效率。<br>灵活：RPC支持多种语言，不同的编程语言可以方便地调用远程接口。<br>通用：RPC可以基于XML、JSON等标准化的数据格式进行通信，使得不同语言之间可以正确地传递数据</td><td>简单易用：RESTful API基于HTTP协议，可以使用常见的HTTP方法（如GET、POST、PUT、DELETE等）进行操作，使得开发人员可以快速上手和使用。 <br>跨平台能力强：RESTful API可以在不同的平台和设备上使用，因为它是基于标准的HTTP协议进行通信。 <br>安全性较高：RESTful API默认基于HTTP协议进行通信，可以使用SSL&#x2F;TLS等安全协议进行加密传输，提高了安全性。 <br>易于测试和调试：RESTful API使用标准的HTTP协议进行通信，可以使用常见的HTTP客户端工具进行测试和调试。</td></tr><tr><td>缺点</td><td>实现复杂：RPC需要实现编码、序列化、网络传输等功能，相比之下比RESTful API实现更复杂。 <br>安全性较低：RESTful API默认是基于HTTP协议进行通信，而RPC则需要自定义通信协议，在安全性方面可能存在一定的风险。 <br>跨平台能力有限：RESTful API可以在不同的平台和设备上使用，而RPC则需要根据不同的语言和平台进行定制化开发。</td><td>传输效率相对较低：相比RPC，RESTful API的报文传输量较大，因为需要携带更多的HTTP头部信息。 <br>性能相对较低：由于需要经过HTTP协议的三次握手等过程，RESTful API的性能相对较低。</td></tr></tbody></table><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/139688497">https://zhuanlan.zhihu.com/p/139688497</a></li><li><a href="https://bbs.huaweicloud.com/blogs/337073">https://bbs.huaweicloud.com/blogs/337073</a></li><li><a href="https://zhuanlan.zhihu.com/p/187560185">https://zhuanlan.zhihu.com/p/187560185</a></li><li><a href="https://www.iamshuaidi.com/25113.html">https://www.iamshuaidi.com/25113.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Go 语言编码规范》学习笔记</title>
    <link href="/2024/01/01/%E3%80%8AGo-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/01/%E3%80%8AGo-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<ol><li><p><strong>所有的提交代码都应该通过 <code>golint</code> 和 <code>go vet</code> 检测</strong></p><p>建议在代码编辑器上面做如下设置：</p><ul><li>保存的时候运行 <code>goimports</code></li><li>使用 <code>golint</code> 和 <code>go vet</code> 去做错误检测。</li></ul></li><li><p><strong>零值Mutex是有效的</strong></p><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mu := <span class="hljs-built_in">new</span>(sync.Mutex)<br>mu.Lock()<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex<br>mu.Lock()<br></code></pre></td></tr></table></figure></li><li><p><strong>在边界处拷贝Slices和Maps</strong></p><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p><p><strong>接收Slices和Maps</strong></p><p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;<br>  d.trips = trips<br>&#125;<br><br>trips := ...<br>d1.SetTrips(trips)<br><br><span class="hljs-comment">// 你是要修改 d1.trips 吗？</span><br>trips[<span class="hljs-number">0</span>] = ...<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;<br>  d.trips = <span class="hljs-built_in">make</span>([]Trip, <span class="hljs-built_in">len</span>(trips))<br>  <span class="hljs-built_in">copy</span>(d.trips, trips)<br>&#125;<br><br>trips := ...<br>d1.SetTrips(trips)<br><br><span class="hljs-comment">// 这里我们修改 trips[0]，但不会影响到 d1.trips</span><br>trips[<span class="hljs-number">0</span>] = ...<br></code></pre></td></tr></table></figure><p><strong>返回slices和maps</strong></p><p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stats <span class="hljs-keyword">struct</span> &#123;<br>  mu sync.Mutex<br><br>  counters <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// Snapshot 返回当前状态。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stats)</span></span> Snapshot() <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  s.mu.Lock()<br>  <span class="hljs-keyword">defer</span> s.mu.Unlock()<br><br>  <span class="hljs-keyword">return</span> s.counters<br>&#125;<br><br><span class="hljs-comment">// snapshot 不再受互斥锁保护</span><br><span class="hljs-comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响</span><br><span class="hljs-comment">// 影响 stats.counters</span><br>snapshot := stats.Snapshot()<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stats <span class="hljs-keyword">struct</span> &#123;<br>  mu sync.Mutex<br><br>  counters <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stats)</span></span> Snapshot() <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  s.mu.Lock()<br>  <span class="hljs-keyword">defer</span> s.mu.Unlock()<br><br>  result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s.counters))<br>  <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> s.counters &#123;<br>    result[k] = v<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-comment">// snapshot 现在是一个拷贝</span><br>snapshot := stats.Snapshot()<br></code></pre></td></tr></table></figure></li><li><p><strong>使用time处理时间</strong></p><p><strong>使用 <code>time.Time</code> 表达瞬时时间</strong></p><p>在处理时间的瞬间时使用 <a href="https://golang.org/pkg/time/#Time"><code>time.Time</code></a>，在比较、添加或减去时间时使用 <code>time.Time</code> 中的方法。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isActive</span><span class="hljs-params">(now, start, stop <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> start &lt;= now &amp;&amp; now &lt; stop<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isActive</span><span class="hljs-params">(now, start, stop time.Time)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用 <code>time.Duration</code> 表达时间段</strong></p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">poll</span><span class="hljs-params">(delay <span class="hljs-type">int</span>)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    time.Sleep(time.Duration(delay) * time.Millisecond)<br>  &#125;<br>&#125;<br>poll(<span class="hljs-number">10</span>) <span class="hljs-comment">// 是几秒钟还是几毫秒？</span><br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">poll</span><span class="hljs-params">(delay time.Duration)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    time.Sleep(delay)<br>  &#125;<br>&#125;<br>poll(<span class="hljs-number">10</span>*time.Second)<br></code></pre></td></tr></table></figure></li><li><p><strong>错误类型</strong></p><p>使用 <a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 表示带有静态字符串的错误。 如果调用者需要匹配并处理此错误，则将此错误导出为变量以支持将其与 <code>errors.Is</code> 匹配。</p><p><strong>无错误匹配</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// package foo</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;could not open&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// package bar</span><br><br><span class="hljs-keyword">if</span> err := foo.Open(); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-comment">// Can&#x27;t handle the error.</span><br>  <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown error&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有错误匹配</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// package foo</span><br><br><span class="hljs-keyword">var</span> ErrCouldNotOpen = errors.New(<span class="hljs-string">&quot;could not open&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">return</span> ErrCouldNotOpen<br>&#125;<br><br><span class="hljs-comment">// package bar</span><br><br><span class="hljs-keyword">if</span> err := foo.Open(); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">if</span> errors.Is(err, foo.ErrCouldNotOpen) &#123;<br>    <span class="hljs-comment">// handle the error</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown error&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于动态字符串的错误， 如果调用者不需要匹配它，则使用 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a>， 如果调用者确实需要匹配它，则自定义 <code>error</code>。</p><p><strong>无错误匹配</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// package foo</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">(file <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;file %q not found&quot;</span>, file)<br>&#125;<br><br><span class="hljs-comment">// package bar</span><br><br><span class="hljs-keyword">if</span> err := foo.Open(<span class="hljs-string">&quot;testfile.txt&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-comment">// Can&#x27;t handle the error.</span><br>  <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown error&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有错误匹配</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// package foo</span><br><br><span class="hljs-keyword">type</span> NotFoundError <span class="hljs-keyword">struct</span> &#123;<br>  File <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *NotFoundError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>  <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;file %q not found&quot;</span>, e.File)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">(file <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;NotFoundError&#123;File: file&#125;<br>&#125;<br><br><br><span class="hljs-comment">// package bar</span><br><br><span class="hljs-keyword">if</span> err := foo.Open(<span class="hljs-string">&quot;testfile.txt&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">var</span> notFound *NotFoundError<br>  <span class="hljs-keyword">if</span> errors.As(err, &amp;notFound) &#123;<br>    <span class="hljs-comment">// handle the error</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown error&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>初始化切片和map时指定容量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]T, length, capacity)<br><span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[T1]T2, hint)<br></code></pre></td></tr></table></figure><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt; b.N; n++ &#123;<br>  data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; size; k++&#123;<br>    data = <span class="hljs-built_in">append</span>(data, k)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">BenchmarkBad-4    100000000    2.48s<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt; b.N; n++ &#123;<br>  data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, size)<br>  <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; size; k++&#123;<br>    data = <span class="hljs-built_in">append</span>(data, k)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">BenchmarkBad-4    100000000    2.48s<br></code></pre></td></tr></table></figure><p><strong>同理：使用map的时候也应该指定容量，减少动态扩容，导致的开销</strong></p></li><li><p><strong>在序列化结构中使用字段标记</strong></p><p>任何序列化到JSON、YAML、， 或其他支持基于标记的字段命名的格式应使用相关标记进行注释。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stock <span class="hljs-keyword">struct</span> &#123;<br>  Price <span class="hljs-type">int</span><br>  Name  <span class="hljs-type">string</span><br>&#125;<br>bytes, err := json.Marshal(Stock&#123;<br>  Price: <span class="hljs-number">137</span>,<br>  Name:  <span class="hljs-string">&quot;UBER&quot;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stock <span class="hljs-keyword">struct</span> &#123;<br>  Price <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;price&quot;`</span><br>  Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>  <span class="hljs-comment">// Safe to rename Name to Symbol.</span><br>&#125;<br>bytes, err := json.Marshal(Stock&#123;<br>  Price: <span class="hljs-number">137</span>,<br>  Name:  <span class="hljs-string">&quot;UBER&quot;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>优先使用strconv而不是fmt</strong></p><p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>  s := fmt.Sprint(rand.Int())<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>  s := strconv.Itoa(rand.Int())<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>避免字符串到字节的转换</strong></p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>  w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello world&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">data := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello world&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>  w.Write(data)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>避免过长的行</strong></p></li><li><p><strong>相似的声明放在一起</strong></p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br><br><span class="hljs-keyword">type</span> Area <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Volume <span class="hljs-type">float64</span><br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>  a = <span class="hljs-number">1</span><br>  b = <span class="hljs-number">2</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>  a = <span class="hljs-number">1</span><br>  b = <span class="hljs-number">2</span><br>)<br><br><span class="hljs-keyword">type</span> (<br>  Area <span class="hljs-type">float64</span><br>  Volume <span class="hljs-type">float64</span><br>)<br></code></pre></td></tr></table></figure></li><li><p><strong>包名命名规范</strong></p><p>当命名包时，请按下面规则选择一个名称：</p><ul><li>全部小写。没有大写或下划线。</li><li>大多数使用命名导入的情况下，不需要重命名。</li><li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li><li>不用复数。例如<code>net/url</code>，而不是<code>net/urls</code>。</li><li>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。</li></ul><p>另请参阅 <a href="https://blog.golang.org/package-names">Go 包命名规则</a> 和 <a href="https://rakyll.org/style-packages/">Go 包样式指南</a>.</p></li><li><p><strong>函数名命名规范</strong></p><p>我们遵循 Go 社区关于使用 <a href="https://golang.org/doc/effective_go.html#mixed-caps">MixedCaps 作为函数名</a> 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：<code>TestMyFunction_WhatIsBeingTested</code>.</p></li><li><p><strong>函数分组与顺序</strong></p><ul><li>函数应按粗略的调用顺序排序。</li><li>同一文件中的函数应按接收者分组。</li></ul><p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。</p><p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>&#x2F;<code>NewXYZ()</code></p><p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *something)</span></span> Cost() &#123;<br>  <span class="hljs-keyword">return</span> calcCost(s.weights)<br>&#125;<br><br><span class="hljs-keyword">type</span> something <span class="hljs-keyword">struct</span>&#123; ... &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcCost</span><span class="hljs-params">(n []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;...&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *something)</span></span> Stop() &#123;...&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSomething</span><span class="hljs-params">()</span></span> *something &#123;<br>    <span class="hljs-keyword">return</span> &amp;something&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> something <span class="hljs-keyword">struct</span>&#123; ... &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSomething</span><span class="hljs-params">()</span></span> *something &#123;<br>    <span class="hljs-keyword">return</span> &amp;something&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *something)</span></span> Cost() &#123;<br>  <span class="hljs-keyword">return</span> calcCost(s.weights)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *something)</span></span> Stop() &#123;...&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcCost</span><span class="hljs-params">(n []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;...&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>减少嵌套</strong></p><p>代码应通过尽可能先处理错误情况&#x2F;特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> data &#123;<br>  <span class="hljs-keyword">if</span> v.F1 == <span class="hljs-number">1</span> &#123;<br>    v = process(v)<br>    <span class="hljs-keyword">if</span> err := v.Call(); err == <span class="hljs-literal">nil</span> &#123;<br>      v.Send()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> err<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    log.Printf(<span class="hljs-string">&quot;Invalid v: %v&quot;</span>, v)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> data &#123;<br>  <span class="hljs-keyword">if</span> v.F1 != <span class="hljs-number">1</span> &#123;<br>    log.Printf(<span class="hljs-string">&quot;Invalid v: %v&quot;</span>, v)<br>    <span class="hljs-keyword">continue</span><br>  &#125;<br><br>  v = process(v)<br>  <span class="hljs-keyword">if</span> err := v.Call(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br>  v.Send()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>不必要的else</strong></p><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br><span class="hljs-keyword">if</span> b &#123;<br>  a = <span class="hljs-number">100</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  a = <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">10</span><br><span class="hljs-keyword">if</span> b &#123;<br>  a = <span class="hljs-number">100</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>nil是一个有效的slice</strong></p><p><code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，您不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> x == <span class="hljs-string">&quot;&quot;</span> &#123;<br>  <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> x == <span class="hljs-string">&quot;&quot;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> s == <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">nums := []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-comment">// or, nums := make([]int)</span><br><br><span class="hljs-keyword">if</span> add1 &#123;<br>  nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> add2 &#123;<br>  nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums []<span class="hljs-type">int</span><br><br><span class="hljs-keyword">if</span> add1 &#123;<br>  nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> add2 &#123;<br>  nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>记住，虽然 nil 切片是有效的切片，但它不等于长度为 0 的切片（一个为 nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p></li><li><p><strong>缩小变量作用域</strong></p><p>如果有可能，尽量缩小变量作用范围。除非它与 减少嵌套的规则冲突。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">err := os.WriteFile(name, data, <span class="hljs-number">0644</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br> <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := os.WriteFile(name, data, <span class="hljs-number">0644</span>); err != <span class="hljs-literal">nil</span> &#123;<br> <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> data, err := os.ReadFile(name); err == <span class="hljs-literal">nil</span> &#123;<br>  err = cfg.Decode(data)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br><br>  fmt.Println(cfg)<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := os.ReadFile(name)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> err := cfg.Decode(data); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> err<br>&#125;<br><br>fmt.Println(cfg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure></li></ol><p>参考：</p><ol><li><a href="https://learnku.com/go/wikis/38426">https://learnku.com/go/wikis/38426</a></li><li>《Go 语言编码规范》中文翻译地址：<a href="https://github.com/xxjwxc/uber_go_guide_cn">https://github.com/xxjwxc/uber_go_guide_cn</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>编码规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang pprof性能分析</title>
    <link href="/2024/01/01/Golang-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2024/01/01/Golang-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一、pprof的主要用途"><a href="#一、pprof的主要用途" class="headerlink" title="一、pprof的主要用途"></a>一、pprof的主要用途</h2><ol><li>CPU性能分析：通过pprof，可以报告程序的CPU使用情况，按照一定频率去采集应用程序在CPU和寄存器上面的数据。</li><li>内存使用情况分析：报告程序的内存使用情况，包括堆内存和栈内存。</li><li>协程情况分析：报告goroutines的使用情况，包括有哪些goroutine以及它们的调用关系是怎样的。</li><li>死锁等性能瓶颈分析：通过报告goroutines不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈。</li></ol><h2 id="二、pprof功能介绍和使用示例"><a href="#二、pprof功能介绍和使用示例" class="headerlink" title="二、pprof功能介绍和使用示例"></a>二、pprof功能介绍和使用示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;runtime&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>log.SetFlags(log.Lshortfile | log.LstdFlags)<br>log.SetOutput(os.Stdout)<br><br>runtime.GOMAXPROCS(<span class="hljs-number">1</span>)              <span class="hljs-comment">// 限制 CPU 使用数，避免过载</span><br>runtime.SetMutexProfileFraction(<span class="hljs-number">1</span>) <span class="hljs-comment">// 开启对锁调用的跟踪</span><br>runtime.SetBlockProfileRate(<span class="hljs-number">1</span>)     <span class="hljs-comment">// 开启对阻塞操作的跟踪</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:6060&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>os.Exit(<span class="hljs-number">0</span>)<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br>doTest()<br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doTest</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;test i:%d&quot;</span>, i)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行以上代码，可以看到控制台在疯狂打印信息</p><p>保持程序运行，打开浏览器访问 <code>http://localhost:6060/debug/pprof/</code>，可以看到如下页面：</p><p><img src="/2024/01/01/Golang-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20240104142818679.png" alt="浏览器打开界面"></p><p>页面上展示了可用的程序运行采样数据，分别有：</p><table><thead><tr><th align="left">类型</th><th align="left">描述</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">allocs</td><td align="left">内存分配情况的采样信息</td><td align="left">可以用浏览器打开，但可读性不高</td></tr><tr><td align="left">blocks</td><td align="left">阻塞操作情况的采样信息</td><td align="left">可以用浏览器打开，但可读性不高</td></tr><tr><td align="left">cmdline</td><td align="left">显示程序启动命令及参数</td><td align="left">可以用浏览器打开，这里会显示 <code>./go-pprof-practice</code></td></tr><tr><td align="left">goroutine</td><td align="left">当前所有协程的堆栈信息</td><td align="left">可以用浏览器打开，但可读性不高</td></tr><tr><td align="left">heap</td><td align="left">堆上内存使用情况的采样信息</td><td align="left">可以用浏览器打开，但可读性不高</td></tr><tr><td align="left">mutex</td><td align="left">锁争用情况的采样信息</td><td align="left">可以用浏览器打开，但可读性不高</td></tr><tr><td align="left">profile</td><td align="left">CPU 占用情况的采样信息</td><td align="left">浏览器打开会下载文件</td></tr><tr><td align="left">threadcreate</td><td align="left">系统线程创建情况的采样信息</td><td align="left">可以用浏览器打开，但可读性不高</td></tr><tr><td align="left">trace</td><td align="left">程序运行跟踪信息</td><td align="left">浏览器打开会下载文件</td></tr></tbody></table><p>由于直接阅读采样信息缺乏直观性，我们需要借助 <code>go tool pprof</code> 命令来排查问题，这个命令是 go 原生自带的，所以不用额外安装。</p><ol><li><p><strong>排查CPU占用过高</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool pprof http://localhost:6060/debug/pprof/profile<br></code></pre></td></tr></table></figure><p>等待一会儿后，进入一个交互式终端：</p><p><img src="/2024/01/01/Golang-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20240104143752789.png" alt="进入终端"></p><p><strong>以上各个参数的意义：</strong></p><ol><li>flat：给定函数上运行耗时</li><li>flat%：同上的 CPU 运行耗时总比例</li><li>sum%：给定函数累积使用 CPU 总比例</li><li>cum：当前函数加上它之上的调用运行总耗时</li><li>cum%：同上的 CPU 运行耗时总比例</li></ol><p>输入 top 命令，查看 CPU 占用较高的调用：</p><p><img src="/2024/01/01/Golang-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20240104143949715.png" alt="top命令"></p><p>输入list doTest可以看到问题具体出现在代码的那一个位置上</p><p><img src="/2024/01/01/Golang-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20240104144246315.png" alt="list doTest结果"></p></li></ol><p>从上面的代码可以看到这里有一个超级大的循环，会占用大量的CPU时间。</p><p>如果我们想要图形化显示调用栈信息，我们可以安装graphviz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install graphviz <span class="hljs-comment"># for macos</span><br>apt install graphviz <span class="hljs-comment"># for ubuntu</span><br>yum install graphviz <span class="hljs-comment"># for centos</span><br></code></pre></td></tr></table></figure><p>安装成功后再在上面的交互式终端输入web，就可以看到一下的图</p><p><img src="/2024/01/01/Golang-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20240104144645584.png" alt="cpu占用图"></p><p>用我们前面生成的文件制作火焰图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool pprof -http=:8081 ~/pprof/pprof.samples.cpu.001.pb.gz <br></code></pre></td></tr></table></figure><p><img src="/2024/01/01/Golang-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20240104145849811.png" alt="火焰图"></p><ol start="2"><li><p><strong>排查内容占用过高</strong></p><p>开启监控收集信息命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool pprof http://localhost:6060/debug/pprof/heap<br></code></pre></td></tr></table></figure><p>用top和list命令排查内存占用高的和问题的代码位置,web可视化界面看问题位置</p></li><li><p><strong>排查频繁内存回收</strong></p><p>为了获取程序运行过程中 GC 日志，我们需要先退出程序，再在重新启动前赋予一个环境变量，同时为了避免其他日志的干扰，使用 grep 筛选出 GC 日志查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GODEBUG=gctrace=1 ./test | grep gc<br></code></pre></td></tr></table></figure><p>开启内存回收监控命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool pprof http://localhost:6060/debug/pprof/allocs<br></code></pre></td></tr></table></figure><p>用top和list命令排查内存占用高的和问题的代码位置,web可视化界面看问题位置</p></li><li><p><strong>排查协程泄漏</strong></p><p>开启监控命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool pprof http://localhost:6060/debug/pprof/goroutine<br></code></pre></td></tr></table></figure><p>用top和list命令排查内存占用高的和问题的代码位置,web可视化界面看问题位置</p></li><li><p><strong>排查锁的争用</strong></p><p>开启监控命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool pprof http://localhost:6060/debug/pprof/mutex<br></code></pre></td></tr></table></figure><p>用top和list命令排查内存占用高的和问题的代码位置,web可视化界面看问题位置</p></li><li><p><strong>排查阻塞操作</strong></p><p>开启监控命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool pprof http://localhost:6060/debug/pprof/block<br></code></pre></td></tr></table></figure><p>用top和list命令排查内存占用高的和问题的代码位置,web可视化界面看问题位置</p></li></ol><h2 id="三、在实际项目中的应用"><a href="#三、在实际项目中的应用" class="headerlink" title="三、在实际项目中的应用"></a>三、在实际项目中的应用</h2><p><strong>main函数里加入以下代码即可</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:6060&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Fatal(err)<br>&#125;<br>os.Exit(<span class="hljs-number">0</span>)<br>&#125;()<br></code></pre></td></tr></table></figure><p>需要引入的包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>)<br></code></pre></td></tr></table></figure><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><ol><li><a href="https://blog.wolfogre.com/posts/go-ppof-practice/#%E6%8E%92%E6%9F%A5-cpu-%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98">https://blog.wolfogre.com/posts/go-ppof-practice/#%E6%8E%92%E6%9F%A5-cpu-%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98</a></li><li><a href="https://www.topgoer.com/%E5%85%B6%E4%BB%96/pprof%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.html">https://www.topgoer.com/%E5%85%B6%E4%BB%96/pprof%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.html</a></li><li><a href="https://golang2.eddycjy.com/posts/ch6/01-pprof-1/">https://golang2.eddycjy.com/posts/ch6/01-pprof-1/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>pprof</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《程序员的38堂成长课》读书笔记</title>
    <link href="/2023/12/25/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8438%E5%A0%82%E6%88%90%E9%95%BF%E8%AF%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/25/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8438%E5%A0%82%E6%88%90%E9%95%BF%E8%AF%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《10x程序员工作法》课程笔记</title>
    <link href="/2023/12/25/%E3%80%8A10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95%E3%80%8B%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/25/%E3%80%8A10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95%E3%80%8B%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>课程学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《可复制的沟通力》读书笔记</title>
    <link href="/2023/12/25/%E3%80%8A%E5%8F%AF%E5%A4%8D%E5%88%B6%E7%9A%84%E6%B2%9F%E9%80%9A%E5%8A%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/25/%E3%80%8A%E5%8F%AF%E5%A4%8D%E5%88%B6%E7%9A%84%E6%B2%9F%E9%80%9A%E5%8A%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>沟通力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高效沟通的技巧与方法</title>
    <link href="/2023/12/25/%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%E7%9A%84%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <url>/2023/12/25/%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%E7%9A%84%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="https://www.hrloo.com/news/110190.html">https://www.hrloo.com/news/110190.html</a></li><li><a href="https://www.zhihu.com/tardis/zm/art/292931625?source_id=1003">https://www.zhihu.com/tardis/zm/art/292931625?source_id=1003</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何写出一篇好的技术方案</title>
    <link href="/2023/12/23/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    <url>/2023/12/23/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="写技术方案的意义"><a href="#写技术方案的意义" class="headerlink" title="写技术方案的意义"></a>写技术方案的意义</h2><p>写技术方案根本目的是提高研发效率和质量，具体体现在以下方面：</p><h3 id="提高沟通效率"><a href="#提高沟通效率" class="headerlink" title="提高沟通效率"></a>提高沟通效率</h3><ol><li>产品：验证技术方案是否能够 match 上产品方案</li><li>测试：验证技术方案对测试方案是否有足够 &amp; 准确的输入</li><li>同事 &amp; leader：参与技术方案评审，验证技术方案的合理性</li><li>新人(不单单指新同学也指新接触这一块的同学)：拿到技术方案可以很快对某一块的事情熟悉起来</li></ol><h3 id="提高开发效率和质量"><a href="#提高开发效率和质量" class="headerlink" title="提高开发效率和质量"></a>提高开发效率和质量</h3><p>对于开发同学，通过写技术方案，把需求和实现提前梳理一遍，减少等到编码阶段才发现前期考虑不全导致返工的情况；并且写好技术方案再编码，使得编码时思维更加清晰，提高编码效率和质量。</p><h2 id="什么样的技术方案是一个好的技术方案"><a href="#什么样的技术方案是一个好的技术方案" class="headerlink" title="什么样的技术方案是一个好的技术方案"></a>什么样的技术方案是一个好的技术方案</h2><p>技术方案是指导具体开发工作的，可以分别从开发的事前、事中、事后来讨论这个问题。</p><h3 id="事前"><a href="#事前" class="headerlink" title="事前"></a>事前</h3><ol><li>明确的目标：整个技术方案要达成什么目的</li><li>低沟通成本：产品测试能从技术方案上获取足够的输入，不需要反复找你确认</li><li>技术选型思考：为什么要这么做?和业内方案相比有什么好处和坏处，如何权衡的</li></ol><h3 id="事中"><a href="#事中" class="headerlink" title="事中"></a>事中</h3><ol><li>少调整：尽可能少的技术方案需要调整， 否则无法完成开发任务</li></ol><h3 id="事后"><a href="#事后" class="headerlink" title="事后"></a>事后</h3><ol><li>少bug：尽可能少的 bug 或者遗漏</li><li>可扩展 &amp; 可复用：相对简单的改动就能支持新增需求，类似场景可复用不需要重复开发</li></ol><p>一篇好的技术方案可以贯穿整个研发的生命周期，并且能起到很好的指导意义，就如同写小说之前作者必须出一个大纲的逻辑是一致的。</p><h2 id="如何写好一篇好的技术方案"><a href="#如何写好一篇好的技术方案" class="headerlink" title="如何写好一篇好的技术方案"></a>如何写好一篇好的技术方案</h2><p>下面列举写出一篇好的技术方案，应该做到的一些点。</p><h2 id="清晰的目标"><a href="#清晰的目标" class="headerlink" title="清晰的目标"></a>清晰的目标</h2><p>满足需求</p><p>可实施</p><p>概要设计</p><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><p>俗话说得好，一图胜千言。在输出技术方案时，除了文字描述外，适当的图表和图像能够更加直观地表达设计意图和操作流程，有助于别人理解方案内容。因此，在制作技术方案时，我们应该注重使用图表和图像来辅助说明，以提升沟通效率和信息传递的准确性。</p><ol><li><p>架构图</p><p>从架构图可以看出模块划分和层次结构以及外部依赖。</p></li><li><p>模型设计</p><p>数据模型设计，E-R 图是必不可少的。我们的服务如果需要做数据持久化，就需要有DB来存储数据。E-R图可以很直观的看出表的结构，每张表的字段设计和表与表之间的关联关系等。</p></li><li><p>时序图</p></li><li><p>流程图</p></li></ol><h3 id="技术选型分析"><a href="#技术选型分析" class="headerlink" title="技术选型分析"></a>技术选型分析</h3><p>需求拆分</p><p>方案的思考</p><p>调研，业界通用的做法</p><p>存储选型，mysql？mongoDB？</p><p>语言选型？</p><h3 id="安全生产"><a href="#安全生产" class="headerlink" title="安全生产"></a>安全生产</h3><p>一图胜千言</p><p>参考</p><ol><li><a href="https://www.51cto.com/article/710330.html">https://www.51cto.com/article/710330.html</a></li><li><a href="https://www.jianshu.com/p/13503e2e7195">https://www.jianshu.com/p/13503e2e7195</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>方案设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《金字塔原理》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《设计模式之禅》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《大话设计模式》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《SQL必知会》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8ASQL%E5%BF%85%E7%9F%A5%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8ASQL%E5%BF%85%E7%9F%A5%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《代码整洁知道：程序员的职业素养》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E7%9F%A5%E9%81%93%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E7%9F%A5%E9%81%93%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《高性能MySQL（第3版）》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《操作系统导论》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《MySQL技术内幕InnoDB存储引擎》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>InnoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Redis设计与实现》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《微服务设计》读书笔记</title>
    <link href="/2023/12/20/%E3%80%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/%E3%80%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go-zero学习笔记</title>
    <link href="/2023/12/20/go-zero%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/go-zero%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务及实现方案</title>
    <link href="/2023/12/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <url>/2023/12/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="https://pdai.tech/md/arch/arch-z-transection.html">https://pdai.tech/md/arch/arch-z-transection.html</a></li><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">https://xiaomi-info.github.io/2020/01/02/distributed-transaction/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>方案设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方案设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ学习笔记</title>
    <link href="/2023/12/20/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ入门"><a href="#RabbitMQ入门" class="headerlink" title="RabbitMQ入门"></a>RabbitMQ入门</h1><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><p>RabbitMQ 是由 erlang 语言开发，基于 AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p><p>官方地址：<a href="http://www.rabbitmq.com/">http://www.rabbitmq.com</a></p><p>官方教程：<a href="http://www.rabbitmq.com/getstarted.html">http://www.rabbitmq.com/getstarted.html</a></p><p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><ol><li>可靠性（Reliability）， RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li><li>灵活的路由（Flexible Routing）， 在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li><li>消息集群（Clustering）， 多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li><li>高可用（Highly Available Queues）， 队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li><li>多种协议（Multi-protocol）， RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>多语言客户端（Many Clients），RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li><li>管理界面（Management UI）， RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</li><li>跟踪机制（Tracing），如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li><li>插件机制（Plugin System）， RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li></ol><h2 id="RabbitMQ架构模型"><a href="#RabbitMQ架构模型" class="headerlink" title="RabbitMQ架构模型"></a>RabbitMQ架构模型</h2><p><img src="/2023/12/20/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/_posts/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/e75977e48886167f5f00536338bfdc31.png" alt="img"></p><p><strong>Connection</strong></p><p>连接，作为客户端（无论是生产者还是消费者），你如果要与 RabbitMQ 通讯的话，你们之间必须创建一条 TCP 连接。</p><p><strong>Channel</strong></p><p>信道，是生产者&#x2F;消费者与 RabbitMQ 通信的渠道。信道是建立在 TCP 连接上的虚拟连接，什么意思呢？就是说 rabbitmq 在一条 TCP 上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个线程对应一个信道，信道在 RabbitMQ 都有唯一的 ID ,保证了信道私有性，对应上唯一的线程使用。</p><p><strong>为什么不建立多个 TCP 连接呢？</strong></p><p>因为对于操纵系统而言，建立和销毁 TCP 是非常昂贵的，系统为每个线程开辟一个 TCP 是非常消耗性能，每秒成百上千的建立销毁 TCP 会严重消耗系统。所以 rabbitmq 选择建立多个信道（建立在 tcp 的虚拟连接）连接到 rabbit 上。</p><p>从技术上讲，这被称之为多路复用，对于执行多个任务的多线程或者异步应用程序来说，它非常有用。</p><p><strong>Message</strong></p><p>消息，包含有效载荷和标签，有效载荷指要传输的数据，标签描述了有效载荷，并且 rabbitmq 用它来决定谁获得消息，消费者只能拿到有效载荷，并不知道生产者是谁。</p><p><strong>Producer</strong></p><p>生产者，消息的创建者，发送到 rabbitmq。</p><p><strong>Consumer</strong></p><p>消费者，消息的消费者，连接到 rabbitmq，订阅到队列上，消费消息，持续订阅和单条订阅。</p><p><strong>Broker</strong></p><p>代理服务，简单来说就是消息队列服务器实体，默认端口 5672。</p><p><strong>Routing Key</strong></p><p>路由规则，虚拟机用它来确认如何路由一个特定消息，即 Exchange 根据这个关键字进行消息投递。</p><p><strong>Binding</strong></p><p>Exchange 和 Queue 之间的虚拟连接，它的作用就是把 exchange 和 queue 按照路由规则绑定起来，Binding 中可以包括多个 Routing key。</p><p><strong>Queue</strong></p><p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><strong>交换机、队列、绑定、路由键之间的关系</strong>：</p><p>队列通过路由键绑定到交换机，生产者将消息发布到交换机，交换机根据绑定的路由键将消息路由到特定队列，然后由订阅这个队列的消费者进行接收。</p><p><img src="/2023/12/20/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/_posts/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/67939e2621fab7bd4f471931f7c77172.png" alt="img"></p><p><strong>Virtual Host</strong></p><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 &#x2F; ，通过缺省用户和口令 guest 进行访问。</p><p><img src="/2023/12/20/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/_posts/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/a7cb7b74287615f6217097f85375dfb4.png" alt="img"></p><h2 id="Exchange交换器的类型"><a href="#Exchange交换器的类型" class="headerlink" title="Exchange交换器的类型"></a>Exchange交换器的类型</h2><p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers，由于headers交换器和direct交换器完全一致，且性能差很多，目前几乎用不到。这里只看direct、fanout、topic这三种类型：</p><ol><li>direct（直连）：消息中的路由键（RoutingKey）如果和 Bingding 中的 bindingKey 完全匹配，交换器就将消息发到对应的队列中。是基于完全匹配、单播的模式。</li><li>fanout（广播）：把所有发送到fanout交换器的消息路由到所有绑定该交换器的队列中，fanout 类型转发消息是最快的。</li><li>topic（主题）：通过模式匹配的方式对消息进行路由，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。匹配规则：<ul><li>RoutingKey 和 BindingKey 为一个 点号 ‘.’ 分隔的字符串。 比如: stock.usd.nyse；可以放任意的key在routing_key中，当然最长不能超过255 bytes。</li><li>BindingKey可使用 * 和 # 用于做模糊匹配：*匹配一个单词，#匹配0个或者多个单词</li></ul></li><li>headers：不依赖于路由键进行匹配，是根据发送消息内容中的headers属性进行匹配，除此之外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了。</li></ol><h2 id="RabbitMQ的几种模式"><a href="#RabbitMQ的几种模式" class="headerlink" title="RabbitMQ的几种模式"></a>RabbitMQ的几种模式</h2><p>RabbitMQ提供了6种模式：</p><ol><li>简单模式：一对一模式，只有一个生产者，一个队列，一个消费者，是最简单的模式。</li><li>工作队列模式：一对多模式，一个消息生产者，一个消息队列，多个消费者。</li><li>Publish&#x2F;Subscribe发布与订阅模式：无选择接收消息，一个消息生产者，一个交换器，多个消息队列，多个消费者。</li><li>Routing路由模式：在发布&#x2F;订阅模式的基础上，有选择的接收消息，也就是通过 routing 路由进行匹配条件是否满足接收消息。</li><li>Topics主题模式：同样是在发布&#x2F;订阅模式的基础上，根据主题匹配进行筛选是否接收消息，比第四类更灵活（也是最常用的一种）。</li><li>RPC远程调用模式（远程调用，不太算MQ；不作介绍）</li></ol><p>官网对应模式介绍：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p><h1 id="RabbitMQ进阶"><a href="#RabbitMQ进阶" class="headerlink" title="RabbitMQ进阶"></a>RabbitMQ进阶</h1><h2 id="过期时间TTL"><a href="#过期时间TTL" class="headerlink" title="过期时间TTL"></a>过期时间TTL</h2><p>Time to Live 简称 TTL，即过期时间。RabbitMQ 可以对 <strong>消息</strong> 和 <strong>队列</strong> 设置 TTL。</p><h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><ol><li><p>通过队列设置：队列中的消息都有相同的过期时间</p></li><li><p>对消息本身设置：每条消息的 TTL 可以不同</p></li></ol><p>如果两种一起设置，则以最小的 TTL 生效。</p><p>消息在队列中生存时间一旦超过 TTL，就会变成「死信（Dead Message）」，消费者将无法收到该消息。</p><h3 id="在队列设置过期时间"><a href="#在队列设置过期时间" class="headerlink" title="在队列设置过期时间"></a>在队列设置过期时间</h3><p>定义队列时，通过参数 <code>x-message-ttl</code> 设置，单位是 <strong>毫秒</strong></p><p>TTL 值的几种情况：</p><ol><li><p>值为 0 ：表示，除非此时可以直接将消息投递到消费者，否则该消息被立即丢弃</p></li><li><p>大于 0：将在该时间内过期</p></li></ol><h3 id="在消息设置过期时间"><a href="#在消息设置过期时间" class="headerlink" title="在消息设置过期时间"></a>在消息设置过期时间</h3><p>此种方式当超过 TTL 时，并不会立即从队列中抹去，而是在投递消费者时判定的。而在队列上一旦过期，则立即从队列中抹去。</p><p>这是因为内部实现的原因导致的：</p><ol><li><p>队列中已过期的消息肯定在队列头部，只要定期从队头开始扫描是否有过期的消息即可</p></li><li><p>在消息中设置的过期，需要扫描整个队列。</p></li></ol><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>Dead Letter Exchange 简称 DLX，可称为死信交换器，当消息在一个 队列中变成死信（dead message）之后，它能被重新发送到另一个交换器中，这个交换器就是DLX，绑定在 DLX 上的队列就称为 死信队列。</p><p>消息变成死信一般有以下几种情况：</p><ol><li>消息被拒绝，并设置 requeue 参数未 false</li></ol><p><code>Basic.Reject 或 Basic.Nack</code></p><ol start="2"><li><p>消息过期</p></li><li><p>队列达到最大长度</p></li></ol><p>DLX 是一个普通的交换器，可以在任何队列上设置，当死信消息出现时，RabbitMQ 自动将这个 消息重新发布到设置的 DLX 上，从而被路由到另一个队列，即 死信队列。</p><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>在 AMQP 协议或 RabbitMQ 中，本身没有直接支持延迟队列的功能。可以 通过 DLX 和 TTL 模拟出延迟队列的功能。</p><p><img src="/2023/12/20/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200624165801409.b1306db4.png" alt="image-20200624165801409"></p><p>上图是死信队列的用法，也是延迟队列的用法。唯一不同的是，消费者订阅的是 <strong>死信队列</strong>，没有消费者订阅普通队列的话，当消息过期时间到了，就会被路由到死信队列，这就达成了，消息被延迟消费的目的。</p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先级高的消息具备 优先被消费的特权。</p><p>在定义队列时，可通过参数 <code>x-max-priority</code> 来指声明此队列的最大优先级别。在发送消息时，给消息设置的最大级别不能超过这个值</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>持久化可以提高 RabbitMQ 的可靠性，防止在异常情况（重启、关闭、宕机等）下的数据丢失。</p><p>RabbitMQ 的持久化分为三个部分：</p><ol><li>交换器的持久化</li></ol><p>在声明交换器是将 durable 参数设置为 true 实现，如果不持久化，RabbitMQ 服务重启之后，相关的交换器元数据会丢失（没有这个交换器了），但是 队列和消息不会丢失（分情况是否设置持久化），只是 不能将消息发送到这个交换器了。</p><ol start="2"><li>队列的持久化</li></ol><p>在声明队列时将 durable 参数设置为 true 实现，如果不持久化，RabbitMQ 服务重启之后，相关的 元数据会丢失，消息也会丢失；</p><ol start="3"><li>消息的持久化</li></ol><p>但是队列的持久化，并 不能保证消息数据不丢失，要保证消息不丢失，需要将消息的投递模式设置为 2 （BasicProperties 中的 deliveryMode 属性）</p><p>不是所有的消息都设置持久化，在一些对可靠性要求不是那么高的消息，可以不采用持久化。这样可以提高整体的吞吐量。</p><p>交换器、队列、消息都设置为持久化，也有可能丢失，有以下一个方面：</p><ul><li><p>autoAck ：自动确认</p><p>在业务系统中，自动确认是最容易丢失的，如果处理过程中发生异常，消息可能就丢了。</p><p>解决方案：改成手动 ack</p></li><li><p>数据刷盘：RabbitMQ 依赖内核的 fsync 函数存盘</p><p>关于 fsync 函数，自己百度；大概就是数据先写缓存，等待缓存写满，或则内核需要重用缓存时，会将该缓存排入输出队列，进而同步到设备上。</p><p>服务器突然断电，就有可能导致丢失一部分数据；</p><p>解决方案：可以使用 RabbitMQ 的镜像队列机制（后面章节会讲解），相当于配置了副本，master 挂掉，会自动切换到 slave 节点，保证了高可用性。</p></li></ul><p>还可以在发送端引 入<strong>事物机制</strong> 或 <strong>发送方确认机制</strong> 来保证消息已经正确发送并存储至 RabbitMQ 中。</p><h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><p>小生产者将消息发送出去之后，消息到底有没有正确到达服务器？如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的。也就是说默认情况下，生产者不知道消息是否正确到达服务器。</p><p>RabbitMQ 针对这个问题，提供了两种解决方式：</p><ol><li><p>事物机制</p></li><li><p>发送方确认（publisher confirm）机制</p></li></ol><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p>消费者客户端可以通过 <strong>推模式</strong> 和 <strong>拉模式</strong> 来获取并消费消息，RabbitMQ 把消息推送后（或客户端主动 ACK）后，RabbitMQ 把当前消息从队列中标记清除。如果由于某些原因无法处理当前接受到的信息，可以通过 <code>channel.basicNack</code> 或则 <code>channel.basicReject</code> 来拒绝掉。</p><p>对于消费者来说，还有几点需要注意：</p><ol><li><p>消息分发</p></li><li><p>消息顺序性</p></li><li><p>弃用 QueueingConsumer</p></li></ol><h1 id="RabbitMQ常见问题与解决方案"><a href="#RabbitMQ常见问题与解决方案" class="headerlink" title="RabbitMQ常见问题与解决方案"></a>RabbitMQ常见问题与解决方案</h1><h2 id="RabbitMQ如何保证消息的可靠性"><a href="#RabbitMQ如何保证消息的可靠性" class="headerlink" title="RabbitMQ如何保证消息的可靠性"></a>RabbitMQ如何保证消息的可靠性</h2><p>消息的传播链路：</p><pre><code class=" mermaid">graph LR生产者-- 生产 ---&gt;RabbitMQ --消费 ---&gt; 消费者</code></pre><p><strong>RabbitMQ消息丢失有3种情况：</strong></p><ol><li><p><strong>生产者弄丢消息的解决方法</strong></p><p>方法一：生产者在发送数据之前开启RabbitMQ的事务(采用该种方法由于事务机制，会导致吞吐量下降，太消耗性能，不太推荐。)</p><p>方法二：开启confirm模式(使用springboot时在application.yml配置文件中做如下配置，实现confirm回调接口，生产者发送消息时设置confirm回调)</p><p>总结：事务机制和 confirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm机制是异步的，你发送个消息之后就可以发送下一个消息，RabbitMQ 接收了之后会异步回调confirm接口通知你这个消息接收到了。一般在生产者这块避免数据丢失，建议使用用 confirm 机制。</p></li><li><p><strong>MQ自身弄丢消息的解决方法</strong></p><p>方法一：创建queue时设置为持久化队列，这样可以保证RabbitMQ持久化queue的元数据，此时还是不会持久化queue里的数据。</p><p>方法二：发送消息时将消息的deliveryMode设置为持久化，此时queue中的消息才会持久化到磁盘。</p><p>总结：同时设置queue和message持久化以后，RabbitMQ 挂了再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据，保证数据不会丢失。但是就算开启持久化机制，也有可能出现上面说的的消息落盘时服务挂掉的情况。这时可以考虑结合生产者的confirm机制来处理，持久化机制开启后消息只有成功落盘时才会通过confirm回调通知生产者，所以可以考虑生产者在生产消息时维护一个正在等待消息发送确认的队列，如果超过一定时间还没从confirm中收到对应消息的反馈，自动进行重发处理。</p></li><li><p><strong>消费者弄丢消息解决方法</strong></p><p>方法：关闭自动ACK，使用手动ACK。RabbitMQ中有一个ACK机制，默认情况下消费者接收到到消息，RabbitMQ会自动提交ACK，之后这条消息就不会再发送给消费者了。我们可以更改为手动ACK模式，每次处理完消息之后，再手动ack一下。不过这样可能会出现刚处理完还没手动ack确认，消费者挂了，导致消息重复消费，不过我们只需要保证幂等性就好了，重复消费也不会造成问题。</p></li></ol><h2 id="RabbitMQ如何保证消息幂等"><a href="#RabbitMQ如何保证消息幂等" class="headerlink" title="RabbitMQ如何保证消息幂等"></a>RabbitMQ如何保证消息幂等</h2><p>如何保证消息队列消费的幂等性，这一块应该还是要结合业务来选择合适的方法，有以下几个方案：</p><ol><li><p>消费数据为了单纯的写入数据库，可以先根据主键查询数据是否已经存在，如果已经存在了就没必要插入了。或者直接插入也没问题，因为可以利用主键的唯一性来保证数据不会重复插入，重复插入只会报错，但不会出现脏数据。</p></li><li><p>消费数据只是为了缓存到redis当中，这种情况就是直接往redis中set value了，天然的幂等性。</p></li><li><p>针对复杂的业务情况，可以在生产消息的时候给每个消息加一个全局唯一ID，消费者消费消息时根据这个ID去redis当中查询之前是否消费过。如果没有消费过，就进行消费并将这个消息的ID写入到redis当中。如果已经消费过了，就无需再次消费了。</p></li></ol><h2 id="RabbitMQ如何保证消息的顺序"><a href="#RabbitMQ如何保证消息的顺序" class="headerlink" title="RabbitMQ如何保证消息的顺序"></a>RabbitMQ如何保证消息的顺序</h2><h3 id="出现消费顺序错乱的情况"><a href="#出现消费顺序错乱的情况" class="headerlink" title="出现消费顺序错乱的情况"></a>出现消费顺序错乱的情况</h3><ol><li>为了提高处理效率，一个queue存在多个consumer</li><li>一个queue只存在一个consumer，但是为了提高处理效率，consumer中使用了多线程进行处理</li></ol><h3 id="保证消息顺序消费的方法"><a href="#保证消息顺序消费的方法" class="headerlink" title="保证消息顺序消费的方法"></a>保证消息顺序消费的方法</h3><ol><li><p>将原来的一个queue拆分成多个queue，每个queue都有一个自己的consumer。该种方案的核心是生产者在投递消息的时候根据业务数据关键值（例如订单ID哈希值对订单队列数取模）来将需要保证先后顺序的同一类数据（同一个订单的数据） 发送到同一个queue当中。</p></li><li><p>一个queue就一个consumer，在consumer中维护多个内存队列，根据业务数据关键值（例如订单ID哈希值对内存队列数取模）将消息加入到不同的内存队列中，然后多个真正负责处理消息的线程去各自对应的内存队列当中获取消息进行消费。</p></li></ol><h3 id="RabbitMQ保证消息顺序性总结"><a href="#RabbitMQ保证消息顺序性总结" class="headerlink" title="RabbitMQ保证消息顺序性总结"></a>RabbitMQ保证消息顺序性总结</h3><p>核心思路就是根据业务数据关键值划分成多个消息集合，而且每个消息集合中的消息数据都是有序的，每个消息集合有自己独立的一个consumer。多个消息集合的存在保证了消息消费的效率，每个有序的消息集合对应单个的consumer也保证了消息消费时的有序性。</p><p>如果业务又要顺序消费，又要增加并发，通常思路就是开启多个队列，业务根据规则将消息分发到不同的队列，通过增加队列的数量来提高并发度，例如：电商订单场景，只需要保证同一个用户的订单消息的顺序性就行，不同用户之间没有关系，所以只要让同一个用户的订单消息进入同一个队列就行，其他用户的订单消息，可以进入不同的队列。</p><h2 id="如何确保消息不丢失"><a href="#如何确保消息不丢失" class="headerlink" title="如何确保消息不丢失"></a>如何确保消息不丢失</h2><p>消息持久化的前提是：将交换器&#x2F;队列的durable属性设置为true，表示交换器&#x2F;队列是持久交换器&#x2F;队列，在服务器崩溃或重启之后不需要重新创建交换器&#x2F;队列（交换器&#x2F;队列会自动创建）。</p><p> 如果消息想要从Rabbit崩溃中恢复，那么消息必须：</p><ul><li>在消息发布前，通过把它的 “投递模式” 选项设置为2（持久）来把消息标记成持久化</li><li>将消息发送到持久交换器</li><li>消息到达持久队列</li></ul><p>RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，Rabbit会在消息提交到日志文件后才发送响应（如果消息路由到了非持久队列，它会自动从持久化日志中移除）。一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前RabbitMQ重启，那么Rabbit会自动重建交换器和队列（以及绑定），并重播持久化日志文件中的消息到合适的队列或者交换器上。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><p><a href="https://www.rabbitmq.com/documentation.html">https://www.rabbitmq.com/documentation.html</a></p></li><li><p><a href="https://www.zhihu.com/question/51126804">https://www.zhihu.com/question/51126804</a></p></li><li><p><a href="https://xie.infoq.cn/article/ab5c07dbe3d5d7896ad44c65e">https://xie.infoq.cn/article/ab5c07dbe3d5d7896ad44c65e</a></p></li><li><p><a href="https://www.cnblogs.com/gygtech/p/14902161.html">https://www.cnblogs.com/gygtech/p/14902161.html</a></p></li><li><p><a href="https://www.cnblogs.com/tanghaorong/p/14914149.html#_label3">https://www.cnblogs.com/tanghaorong/p/14914149.html#_label3</a></p></li><li><p><a href="https://zq99299.github.io/mq-tutorial/rabbitmq-ac/">https://zq99299.github.io/mq-tutorial/rabbitmq-ac/</a></p></li><li><p><a href="https://learnku.com/articles/39963">https://learnku.com/articles/39963</a></p></li><li><p><a href="https://juejin.cn/post/6844904125935665160">https://juejin.cn/post/6844904125935665160</a></p></li><li><p><a href="https://rabbitmq.mr-ping.com/AMQP/AMQP_0-9-1_Model_Explained.html">https://rabbitmq.mr-ping.com/AMQP/AMQP_0-9-1_Model_Explained.html</a></p></li><li><p><a href="https://www.cnblogs.com/hello-/articles/10345021.html">https://www.cnblogs.com/hello-/articles/10345021.html</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch学习笔记</title>
    <link href="/2023/12/20/ElasticSearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/ElasticSearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka学习笔记</title>
    <link href="/2023/12/20/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang编码规范和建议</title>
    <link href="/2023/12/20/Golang%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E5%92%8C%E5%BB%BA%E8%AE%AE/"/>
    <url>/2023/12/20/Golang%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E5%92%8C%E5%BB%BA%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记</title>
    <link href="/2023/12/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="/2023/12/20/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB学习笔记</title>
    <link href="/2023/12/20/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令和使用规范</title>
    <link href="/2023/12/19/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <url>/2023/12/19/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Git常用命令列表"><a href="#一、Git常用命令列表" class="headerlink" title="一、Git常用命令列表"></a>一、Git常用命令列表</h2><ol><li><p><code>git config</code>： 设置 Git 配置值</p><p>设置 Git 用户名</p><p>创建 Git 别名</p><p>设置 Git 编辑器</p><p>列出 Git 配置属性</p></li><li><p><code>git init</code> ： 创建一个新的 Git 仓库</p></li><li><p><code>git clone</code> ： 克隆一个 Git 仓库</p></li><li><p><code>git add</code>： 添加文件内容到暂存区</p><p>添加单个文件</p><p>添加多个文件</p><p>添加所有文件</p><p>添加删除和修改的文件</p><p>在当前目录中添加文件</p><p>添加具有特定文件扩展名的文件</p></li><li><p><code>git rm -f</code>： 从 Git 存储库中删除文件</p><p>删除单个文件</p><p>删除多个文件</p><p>删除目录</p></li><li><p><code>git mv</code>： 移动或重命名 Git 存储库文件</p><p>重命名项目文件</p><p>移动项目文件</p></li><li><p><code>git commit</code>： 将更改保存到 Git 存储库</p><p>添加新提交</p><p>修复先前的提交</p><p>提交修改后的文件</p></li><li><p><code>git branch</code>： 列出、创建或删除分支</p><p>列出存储库分支</p><p>创建一个新分支</p><p>删除现有分支</p></li><li><p><code>git status</code> ： 显示存储库和暂存区的状态</p></li><li><p><code>git diff</code>： 跟踪文件中的更改</p><p>显示未暂存但已修改的更改</p><p>显示分阶段但未提交的更改</p><p>显示两个分支之间的差异</p><p>比较已提交与未提交的文件</p><p>比较两个特定文件版本</p></li><li><p><code>git log</code>： 显示提交历史</p><p>显示提交历史</p><p>过滤 Git 日志</p></li><li><p><code>git checkout</code>： 在分支之间切换</p><p>切换到现有分支</p><p>切换到新分支</p><p>恢复文件的先前版本</p></li><li><p><code>git merge</code>：合并 Git 分支</p></li><li><p><code>git fetch</code> ： 下载远程 Git 存储库</p></li><li><p><code>git pull</code>：下载并合并 Git 仓库</p></li><li><p><code>git push</code>：使用本地提交更新远程分支</p></li><li><p><code>git rebase</code> ： 更改一系列提交</p></li><li><p><code>git revert</code> ： 还原现有提交</p></li><li><p><code>git reset</code> ： 还原 Git 存储库提交</p></li><li><p><code>git stash</code> ： 在本地保存未提交的更改</p></li><li><p><code>git reflog</code> ： 跟踪分支的变化</p></li></ol><h2 id="二、Git常用命令用法详情"><a href="#二、Git常用命令用法详情" class="headerlink" title="二、Git常用命令用法详情"></a>二、Git常用命令用法详情</h2><ol><li><p><strong><code>git config</code>： 设置 Git 配置值</strong></p><p><strong>设置 Git 用户名</strong></p><p>要全局设置与git存储库关联的用户名和电子邮件地址，请执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;your_username&quot;</span> <br>git config --global user.email <span class="hljs-string">&quot;your_email_address&quot;</span><br></code></pre></td></tr></table></figure><p>也可以执行<code>vi ~/.gitconfig</code>，修改全局的gitconfig配置文件，在配置文件加入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[user]<br>        name = your_username<br>        email = your_email_address<br></code></pre></td></tr></table></figure><p>要在项目基础上（不是全局）设置存储库的用户名和密码，请执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config user.name <span class="hljs-string">&quot;your_username&quot;</span><br>git config user.email <span class="hljs-string">&quot;your_email_address&quot;</span><br></code></pre></td></tr></table></figure><p>也可以在对应项目根目录下执行<code>vi .git/config</code>修改项目的git配置文件，在配置文件加入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[user]<br>        name = your_username<br>        email = your_email_address<br></code></pre></td></tr></table></figure><p><strong>创建Git别名</strong></p><p>我们还可以使用git config命令创建 Git 别名，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global alias.s status <br></code></pre></td></tr></table></figure><p><strong>设置 Git 编辑器</strong></p><p>git config命令也非常适合用于在编写或编辑提交消息时设置用户的首选文本编辑器：将“ editor-name ”替换为您正在使用的文本编辑器的名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.editor <span class="hljs-string">&quot;editor-name&quot;</span> [Globally]<br>git config core.editor <span class="hljs-string">&quot;editor-name&quot;</span>          [Project Basis]<br></code></pre></td></tr></table></figure><p><strong>列出 Git 配置属性</strong></p><p>此外，可以使用以下git config命令查看活动存储库的当前配置选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git init</code> ： 创建一个新的 Git 仓库</strong></p><p>git init命令可以在本地文件系统的当前目录上初始化 Git 存储库。它还创建一个’.git’子目录（隐藏目录），其中包含必要的存储库文件，如索引和对象数据库文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init <br></code></pre></td></tr></table></figure></li><li><p><strong><code>git clone</code>：克隆一个 Git 仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [URL]<br></code></pre></td></tr></table></figure><p><strong>下载指定目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [URL] [<span class="hljs-built_in">dir</span>]<br></code></pre></td></tr></table></figure><p>下载指定分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b [branch] [URL]<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git add</code>： 添加文件内容到暂存区</strong></p><p><strong>添加文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add test.go<br></code></pre></td></tr></table></figure><p><strong>添加多个文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add test1.go test2.go<br></code></pre></td></tr></table></figure><p><strong>添加当前目录下的全部文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git rm -f</code>：从 Git 存储库中删除文件</strong></p><p>git rm命令可用于从 git 存储库中删除不需要的项目文件。该-f标志强制删除带有阻止正常删除限制的文件。它还会暂存已删除的文件以供提交，以便托管存储库知道已删除的项目文件。</p><p><strong>删除单个文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> -f file4.txt<br></code></pre></td></tr></table></figure><p><strong>删除多个文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">rm</span> file1.txt file2.php file3.py file4<br></code></pre></td></tr></table></figure><p><strong>删除目录</strong></p><p>我们还可以使用-r标志递归地删除项目目录及其内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">rm</span> -f -r directory_name<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git mv</code>：移动或重命名git仓库文件</strong></p><p>git mv命令移动并重命名 Git 存储库文件。来自这些移动和重命名操作的更改也被暂存以提交到存储库。</p><p><strong>重命名项目文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">mv</span> old-name.txt new-name.txt<br></code></pre></td></tr></table></figure><p><strong>移动项目文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ba">$ git mv file3.txt beta/file3.txt<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git commit</code>：将更改保存到Git仓库</strong></p><p><strong>添加提交</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;注释&quot;</span><br></code></pre></td></tr></table></figure><p><strong>修改上一个提交的注释</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit --amend -m <span class="hljs-string">&quot;新的注释&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>git branch</code>：列出、创建或删除分支</strong></p><p><strong>列出当前仓库本地的所有分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p><strong>创建新的分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch 分支名<br></code></pre></td></tr></table></figure><p><strong>删除分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d 分支名<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git status</code>：显示存储库和暂存区的状态</strong></p><p>显示存储库和暂存区的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git diff</code>：跟踪文件中的更改</strong></p><p><strong>显示未暂存但已修改的更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff<br></code></pre></td></tr></table></figure><p><strong>显示暂存但未提交的更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff --staged <br></code></pre></td></tr></table></figure><p><strong>显示两个分支的差异</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff Branch_1...Branch_2<br></code></pre></td></tr></table></figure><p><strong>显示指定分支和当前分支代码的差异</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff branch-name<br></code></pre></td></tr></table></figure><p><strong>比较已提交和未提交的文件状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff file-name<br></code></pre></td></tr></table></figure><p><strong>比较两个特定的文件版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff commit-id-1 commit-id-2 file-name<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git log</code>：显示提交历史</strong></p><p><strong>显示提交历史</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><strong>按作者过滤</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --author=author_name<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git checkout</code>：在分支之间切换</strong></p><p><strong>切换到指定分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout 分支名<br></code></pre></td></tr></table></figure><p><strong>创建并切换到新分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b 新分支名<br></code></pre></td></tr></table></figure><p><strong>恢复文件到指定版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout HEAD -- file3.txt<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git merge</code>：合并两个分支</strong></p><p>合并master分支到当前分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge master<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git fetch</code>：下载远程Git存储库</strong></p><p><strong>git fetch</strong>命令下载远程存储库的最新版本并更新此存储库的等效本地副本。它在本地存储检索到的引用、文件和提交，而不将它们与本地存储库合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git pull</code>：下载并合并Git仓库</strong></p><p>我们使用<strong>git pull</strong>命令下载远程存储库的最新版本，然后将其与等效的本地存储库副本合并。<strong>git pull</strong>命令结合了<strong>git fetch</strong>和<strong>git merge</strong>命令的功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git push</code>：使用本地提交更新到远程分支</strong></p><p><strong>git push</strong>命令使远程存储库分支能够接收本地分支提交。当本地存储库领先于（更多更新）远程存储库时，我们使用此命令。它使远程存储库与本地存储库中的新更改保持同步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git rebase</code>：更改一系列提交</strong></p><p><strong>git rebase</strong>命令将 branchA 的更改<strong>集成</strong>到branchB<strong>中</strong>。它采用当前分支的本地提交并在更新的代码版本之上重播它们，而不是采用“ <strong>git merge</strong> ”命令方法来创建新提交并合并更改。</p><p>考虑以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase branch1<br></code></pre></td></tr></table></figure><p>在这里，当前分支的提交在<strong>branch1 的</strong>更新代码版本之上重新应用。只有在没有发生分支冲突时，rebase 操作才会完成。否则，您需要先解决冲突。</p><p>作为<strong>git merge</strong>命令的替代方法，<strong>git rebase</strong>创建了一个更易于理解和解释的线性提交历史记录。</p><p>虽然<strong>git merge</strong>是非破坏性的，但<strong>git rebase</strong>有潜在的缺陷。它通过生成新的提交来重写项目历史。</p><p>考虑以下 git rebase 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br>git rebase loco<br></code></pre></td></tr></table></figure><p>上面的命令将整个<strong>主</strong>分支移动到一个<strong>loco</strong>分支的顶端。所有<strong>本地</strong>分支提交也被合并。</p></li><li><p><strong><code>git revert</code>：还原现有提交</strong></p><p>当需要恢复现有&#x2F;以前的提交时，git revert命令很有用。它撤消以前&#x2F;现有的 Git 存储库更改。它为还原的提交更改创建一个新的提交，并使存储库处于干净状态，就好像这些已删除更改的实现从未发生过一样。</p><p><strong>git revert</strong>命令的语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert &lt;commit_hash&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git reset</code>：还原 Git 存储库提交</strong></p><p><strong>git reset</strong>命令撤消 Git 存储库提交。撤消的提交可以从存储库中永久删除，因此可以使用此命令丢弃它们。它还将存储库重置为先前的状态，并移至分支指针的先前提交</p><p>要取消暂存特定项目文件并保留当前工作目录更改，请执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset [file_name]<br></code></pre></td></tr></table></figure><p>要清除暂存区并根据特定提交重写工作树，请执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard [commit_hash] <br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>git reset</code>会永久删除提交记录，不可找回</p></li><li><p><strong><code>git stash</code>：在本地保存未提交的更改</strong></p><p><strong>git stash</strong>命令临时搁置项目更改，如跟踪和修改的文件，而用户在返回以重新应用这些项目更改之前处理其他内容（例如切换分支）。这些临时保存的更改不会提交 ( <strong>git commit</strong> )。</p><p><strong>要保存已修改和暂存的项目更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git relog</code>：跟踪分支的变化</strong></p><p><strong>git reflog</strong>命令在处理参考日志时很有用。它在显示 Git 存储库中的更改历史记录时引用本地分支。此命令的输出需要提交哈希、执行的操作和与更改相关的分支名称。</p><p>对于最近的还原、拉取、提交等的 HEAD reflog，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog<br></code></pre></td></tr></table></figure></li></ol><h2 id="三、Git命令使用规范和建议"><a href="#三、Git命令使用规范和建议" class="headerlink" title="三、Git命令使用规范和建议"></a>三、Git命令使用规范和建议</h2><ol><li><p>回滚提交时，用<code>git revert</code>代替<code>git reset</code></p><p>git reset命令撤消 Git 存储库提交。撤消的提交可以从存储库中永久删除，这个命令的好处是提交会被永久删除，坏处也是提交会被永久删除，后续如果我们要回滚到对应的提交就办法做到了。如果我们有需要回滚到指定的提交，建议使用<code>git revert</code>，git revert不会删除任何提交记录，这样子能保证每一次的修改和提交都有记录可查。</p></li></ol><p>参考：</p><ol><li><a href="https://bbs.huaweicloud.com/blogs/388474">https://bbs.huaweicloud.com/blogs/388474</a></li><li><a href="https://cloud.tencent.com/developer/article/1910779">https://cloud.tencent.com/developer/article/1910779</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法Golang实现</title>
    <link href="/2023/12/18/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Golang%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/12/18/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Golang%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈DFS和BFS</title>
    <link href="/2023/12/18/%E6%B5%85%E8%B0%88DFS%E5%92%8CBFS/"/>
    <url>/2023/12/18/%E6%B5%85%E8%B0%88DFS%E5%92%8CBFS/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈动态规划</title>
    <link href="/2023/12/18/%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/12/18/%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎么绘制时序图</title>
    <link href="/2023/12/16/%E6%80%8E%E4%B9%88%E7%BB%98%E5%88%B6%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    <url>/2023/12/16/%E6%80%8E%E4%B9%88%E7%BB%98%E5%88%B6%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是时序图"><a href="#一、什么是时序图" class="headerlink" title="一、什么是时序图"></a>一、什么是时序图</h2><p>时序图(Sequence Diagram)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</p><h2 id="二、绘制时序图常用的工具"><a href="#二、绘制时序图常用的工具" class="headerlink" title="二、绘制时序图常用的工具"></a>二、绘制时序图常用的工具</h2><p>绘制时序图常用的工具有：</p><ol><li><p><a href="https://www.processon.com/">processon</a>，拖拽图形作图。</p><p>优点：易上手，自由度较高。</p><p>缺点：作图效率低。</p></li><li><p>MarkDown，写代码作图。</p><p>优点：会自动按照时序图规则调整图形和文字位置，作图效率高。</p><p>缺点：需要学习作图语法，有一定学习成本。</p></li></ol><h2 id="三、时序图组成元素"><a href="#三、时序图组成元素" class="headerlink" title="三、时序图组成元素"></a>三、时序图组成元素</h2><p>时序图中包括如下5个元素：角色、对象、生命线、控制焦点、消息。</p><ol><li><p>角色（Actor）</p><p>系统角色，可以是人、机器、其他系统、子系统</p></li><li><p>对象（Object）</p><p>（1）对象的三种命名方式</p><ul><li>第一种方式包括对象名和类名，例如：直播课时:课时，在时序图中，用“对象：类”表示；</li><li>第二种方式只显示类名，即表示它是一个匿名对象，例如： :课程；在时序图中，用“：类”表示；</li><li>第三种方式只显示对象名不显示类名，例如：讲师；在时序图中，用“对象”表示。</li></ul><p>（2）命名方式的选择</p><p>三种命名方式均可，哪种最容易让阅读该时序图的人理解，就选择哪种。</p><p>（3）对象的排列顺序</p><p>对象的左右顺序并不重要，但是为了作图清晰整洁，通常应遵循以下两个原则：把交互频繁的对象尽可能的靠拢；2.把初始化整个交互活动的对象放置在最左端。</p></li><li><p>生命线（Lifeline）</p><p>在时序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间。</p></li><li><p>控制焦点（Focus of Control）</p><p>又称为激活期，表示时间段的符号，在这个时间段内对象将执行相应的操作。它可以被理解成C语言语义中一对花括号{ }中的内容；用小矩形表示。</p></li><li><p>消息（Message）</p><p>消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）。</p><ul><li>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义；</li><li>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。</li><li>返回消息表示从过程调用返回。</li></ul></li></ol><h2 id="四、时序图语法"><a href="#四、时序图语法" class="headerlink" title="四、时序图语法"></a>四、时序图语法</h2><h2 id="五、时序图例子学习"><a href="#五、时序图例子学习" class="headerlink" title="五、时序图例子学习"></a>五、时序图例子学习</h2><pre><code class=" mermaid">sequenceDiagramClient-&gt;&gt;Gateway : 发送JSON RPC请求Gateway--&gt;&gt;Client : 把JSON RPC响应发送给客户端</code></pre><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><ol><li><a href="https://www.woshipm.com/ucd/607593.html">https://www.woshipm.com/ucd/607593.html</a></li><li><a href="https://juejin.cn/post/7038144693867118629">https://juejin.cn/post/7038144693867118629</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>画图</tag>
      
      <tag>时序图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式锁的实现</title>
    <link href="/2023/12/16/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/12/16/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/asd051377305/article/details/108384490">https://blog.csdn.net/asd051377305/article/details/108384490</a></p>]]></content>
    
    
    <categories>
      
      <category>方案设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>分布式</tag>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决GitHub打不开和访问慢等问题</title>
    <link href="/2023/12/15/GitHub%E6%89%93%E4%B8%8D%E5%BC%80%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2023/12/15/GitHub%E6%89%93%E4%B8%8D%E5%BC%80%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>在家里的网络，GitHub经常打不开或者响应时间很长，这里分享一下如何解决GitHub访问慢的问题。</p><h3 id="二、原因"><a href="#二、原因" class="headerlink" title="二、原因"></a>二、原因</h3><p>GitHub访问慢本质上是我们在访问GitHub网页的时候无法通过github.com的二级域名进行域名解析。</p><h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><p>手动修改设备的hosts文件，将该域名和IP的映射关系添加到设备的hosts文件中，在访问地址时会优先通过Hosts文件进行域名解析。</p><h3 id="四、解决步骤"><a href="#四、解决步骤" class="headerlink" title="四、解决步骤"></a>四、解决步骤</h3><ol><li>找到github.com域名对应的IP地址，输入网址：<a href="https://tool.chinaz.com/dns/?type=1">站长工具Dns查询</a>找出最快的IP地址</li></ol><p><img src="/2023/12/15/GitHub%E6%89%93%E4%B8%8D%E5%BC%80%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/img_1.png" alt="输入域名"><br><img src="/2023/12/15/GitHub%E6%89%93%E4%B8%8D%E5%BC%80%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/img.png" alt="选取ip"></p><ol start="2"><li>修改hosts，把最快的ip填入hosts</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><ol start="3"><li>再次执行命令刷新DNS</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo killall -HUP mDNSResponder;say DNS cache has been flushed<br></code></pre></td></tr></table></figure><ol start="4"><li>再次打开<a href="https://github.com/">GitHub</a>,可以访问了，大功告成</li></ol>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>借助Hexo+GitHub Pages零成本搭建个人博客</title>
    <link href="/2023/12/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/12/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="一、前期准备工作"><a href="#一、前期准备工作" class="headerlink" title="一、前期准备工作"></a>一、前期准备工作</h2><p>注：我的电脑是mac，后面的全部指令都是mac上操作的</p><ol><li>申请GitHub账号</li><li>本地安装Git</li><li>本地NodeJS<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install node<br></code></pre></td></tr></table></figure></li><li>本地安装Hexo<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li></ol><h2 id="二、用Hexo生成博客项目"><a href="#二、用Hexo生成博客项目" class="headerlink" title="二、用Hexo生成博客项目"></a>二、用Hexo生成博客项目</h2><ol><li>初始化博客<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init my-blog<br><span class="hljs-built_in">cd</span> my-blog<br>npm install<br></code></pre></td></tr></table></figure></li><li>生成网页文件&amp;本地启动<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate <span class="hljs-comment"># 生成页面，此命令可以简写为 `hexo g`</span><br>hexo server <span class="hljs-comment"># 本地启动，可简写为 `hexo s`</span><br></code></pre></td></tr></table></figure>通过 hexo g 生成的页面文件在项目 public 目录下;<br>使用 hexo clean 命令可以清理生成的页面文件。当配置未生效时，建议执行清理命令。</li><li>本地访问<br>浏览器访问：<a href="http://localhost:4000/">http://localhost:4000/</a> 会看到一个比较简陋的页面。没关系，接下来介绍如何更换主题。</li></ol><h2 id="三、安装-配置主题"><a href="#三、安装-配置主题" class="headerlink" title="三、安装&amp;配置主题"></a>三、安装&amp;配置主题</h2><p>官方提供了数百种主题任君选择，可以根据个人喜好更换，具体可以点击 (<a href="https://hexo.io/themes/">https://hexo.io/themes/</a>) 查看。<br>本文将主要介绍 Fluid 主题的安装与配置。</p><ol><li>安装 Fluid 主题<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure>在博客根路径下创建 _config.fluid.yml 文件，并将主题的 .&#x2F;node_modules&#x2F;hexo-theme-fluid&#x2F;_config.yml 文件内容复制过去</li><li>指定主题<br>将如下修改应用到 Hexo 博客目录中的 _config.yml:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: fluid  <span class="hljs-comment"># 指定主题</span><br>language: zh-CN  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure></li><li>创建「关于页」<br>首次使用主题的「关于页」需要手动创建。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure>创建成功后修改 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。修改后的文件示例如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-string">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-string">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure>需要注意的是， layout: about 必须存在，并且不能修改成其他值，否则不会显示头像等样式。</li><li>更新 Fluid 主题<br>通过 npm 安装主题的情况，可在博客目录下执行命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm update --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li><li>本地启动</li></ol><p>  执行如下命令重新生成页面，并启动 Hexo 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp; hexo g &amp; hexo s<br></code></pre></td></tr></table></figure><p>再次通过浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> , 便可以看到页面变得美观多了。</p><h2 id="四、创建文章"><a href="#四、创建文章" class="headerlink" title="四、创建文章"></a>四、创建文章</h2><ol><li>修改 _config.yml 文件。这项配置是为了在生成文章的同时，生成一个同名的资源目录用于存放图片等资源文件。</li></ol><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol start="2"><li>创建文件名为 my-blog-build-remark 文章。</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> my-blog-build-remark<br></code></pre></td></tr></table></figure><ol start="3"><li>设置文章的标题及其他元素信息。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">借助Hexo+GitHub</span> <span class="hljs-string">Pages零成本搭建个人博客</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">&#x27;hexo&#x27;</span>,<span class="hljs-string">&#x27;fluid&#x27;</span>]<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ol start="4"><li>如上命令执行成功后，在 source&#x2F;_posts&#x2F; 目录下生成了一个 Markdown 文件和一个同名的资源目录。<br>在 source&#x2F;_posts&#x2F;my-blog-build-remark 目录中放置一个图片文件 posts-file-tree.png，整体目录结构如下：</li></ol><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dos">$ source/_posts (main)&gt; <span class="hljs-built_in">tree</span><br>.<br>├── hello-world.<span class="hljs-built_in">md</span><br>├── my-blog-build-remark<br>│   └── img.png<br>└── my-blog-build-remark.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><ol start="5"><li>文章中插入图片</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">!<span class="hljs-selector-attr">[图片备注]</span>(./my-blog-build-remark/<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.png</span>)<br></code></pre></td></tr></table></figure><p>文章创建并编辑好之后，就可以通过 <code>hexo g &amp;&amp; hexo s</code> 命令启动服务，并在本地预览文章。</p><h2 id="五、发布GitHub-Pages"><a href="#五、发布GitHub-Pages" class="headerlink" title="五、发布GitHub Pages"></a>五、发布GitHub Pages</h2><ol><li>在GitHub上建立仓库</li><li>token获取<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">登录G<span class="hljs-function"><span class="hljs-title">itHub</span>-&gt;</span>S<span class="hljs-function"><span class="hljs-title">ettings</span>-&gt;</span>D<span class="hljs-function"><span class="hljs-title">eveloper</span> settings-&gt;</span>P<span class="hljs-function"><span class="hljs-title">ersonal</span> access tokens-&gt;</span>T<span class="hljs-function"><span class="hljs-title">okens</span>-&gt;</span>Generate a personal access token<br></code></pre></td></tr></table></figure></li><li>修改站点配置 _config.yml<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> <span class="hljs-params">&lt;repository url&gt;</span> <span class="hljs-meta"># https:<span class="hljs-comment">//github.com/&lt;GitHub用户名&gt;/&lt;GitHub用户名&gt;.github.io.git</span></span><br><span class="hljs-symbol">  branch:</span> [branch]<br><span class="hljs-symbol">  token:</span> [token]<br></code></pre></td></tr></table></figure></li><li>生成站点文件并推送至远程 GitHub 仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp; hexo deploy<br></code></pre></td></tr></table></figure>只需稍等片刻，个人博客站点就会显示在 Github Pages 中。</li></ol><h2 id="六、可能会遇到的问题"><a href="#六、可能会遇到的问题" class="headerlink" title="六、可能会遇到的问题"></a>六、可能会遇到的问题</h2><ol><li>文章中插入图片浏览器显示不出来的解决办法<br><img src="/2023/12/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/img.png" alt="图片显示不出来"><br>上面的错误是因为Hexo缺少处理图片的插件，导致生成的代码用的图片链接是相对路径，如果要让浏览器能够访问图片需要用绝对路径。<br>这里需要下载插件帮助我们处理图片路径问题。安装插件命令如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-filter-image --save<br></code></pre></td></tr></table></figure>安装完重新生成代码就可以了<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo  clean<br>hexo g &amp; hexo s<br></code></pre></td></tr></table></figure></li></ol><h2 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h2><ol><li>Hexo Docs：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></li><li>Hexo Fluid 用户手册：<a href="https://fluid-dev.github.io/hexo-fluid-docs/">https://fluid-dev.github.io/hexo-fluid-docs/</a></li><li><a href="https://xie.infoq.cn/article/ac51ce1f6e9434779c35cbb6c">https://xie.infoq.cn/article/ac51ce1f6e9434779c35cbb6c</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
