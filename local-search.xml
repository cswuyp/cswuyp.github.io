<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《Effective Go》读书笔记</title>
    <link href="/2024/01/02/%E3%80%8AEffective-Go%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/02/%E3%80%8AEffective-Go%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><p>《Effective Go》官方地址：<a href="https://go.dev/doc/effective_go">https://go.dev/doc/effective_go</a></p></li><li><p>《Effective Go》中英双语版地址：<a href="https://github.com/bingohuang/effective-go-zh-en">https://github.com/bingohuang/effective-go-zh-en</a></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《Go 语言编码规范》学习笔记</title>
    <link href="/2024/01/01/%E3%80%8AGo-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/01/%E3%80%8AGo-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<ol><li><p><strong>所有的提交代码都应该通过 <code>golint</code> 和 <code>go vet</code> 检测</strong></p><p>建议在代码编辑器上面做如下设置：</p><ul><li>保存的时候运行 <code>goimports</code></li><li>使用 <code>golint</code> 和 <code>go vet</code> 去做错误检测。</li></ul></li><li><p><strong>零值Mutex是有效的</strong></p><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mu := <span class="hljs-built_in">new</span>(sync.Mutex)<br>mu.Lock()<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex<br>mu.Lock()<br></code></pre></td></tr></table></figure></li><li><p><strong>在边界处拷贝Slices和Maps</strong></p><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p><p><strong>接收Slices和Maps</strong></p><p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;<br>  d.trips = trips<br>&#125;<br><br>trips := ...<br>d1.SetTrips(trips)<br><br><span class="hljs-comment">// 你是要修改 d1.trips 吗？</span><br>trips[<span class="hljs-number">0</span>] = ...<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;<br>  d.trips = <span class="hljs-built_in">make</span>([]Trip, <span class="hljs-built_in">len</span>(trips))<br>  <span class="hljs-built_in">copy</span>(d.trips, trips)<br>&#125;<br><br>trips := ...<br>d1.SetTrips(trips)<br><br><span class="hljs-comment">// 这里我们修改 trips[0]，但不会影响到 d1.trips</span><br>trips[<span class="hljs-number">0</span>] = ...<br></code></pre></td></tr></table></figure><p><strong>返回slices和maps</strong></p><p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stats <span class="hljs-keyword">struct</span> &#123;<br>  mu sync.Mutex<br><br>  counters <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// Snapshot 返回当前状态。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stats)</span></span> Snapshot() <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  s.mu.Lock()<br>  <span class="hljs-keyword">defer</span> s.mu.Unlock()<br><br>  <span class="hljs-keyword">return</span> s.counters<br>&#125;<br><br><span class="hljs-comment">// snapshot 不再受互斥锁保护</span><br><span class="hljs-comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响</span><br><span class="hljs-comment">// 影响 stats.counters</span><br>snapshot := stats.Snapshot()<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stats <span class="hljs-keyword">struct</span> &#123;<br>  mu sync.Mutex<br><br>  counters <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stats)</span></span> Snapshot() <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  s.mu.Lock()<br>  <span class="hljs-keyword">defer</span> s.mu.Unlock()<br><br>  result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s.counters))<br>  <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> s.counters &#123;<br>    result[k] = v<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-comment">// snapshot 现在是一个拷贝</span><br>snapshot := stats.Snapshot()<br></code></pre></td></tr></table></figure></li><li><p><strong>使用time处理时间</strong></p><p><strong>使用 <code>time.Time</code> 表达瞬时时间</strong></p><p>在处理时间的瞬间时使用 <a href="https://golang.org/pkg/time/#Time"><code>time.Time</code></a>，在比较、添加或减去时间时使用 <code>time.Time</code> 中的方法。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isActive</span><span class="hljs-params">(now, start, stop <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> start &lt;= now &amp;&amp; now &lt; stop<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isActive</span><span class="hljs-params">(now, start, stop time.Time)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用 <code>time.Duration</code> 表达时间段</strong></p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">poll</span><span class="hljs-params">(delay <span class="hljs-type">int</span>)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    time.Sleep(time.Duration(delay) * time.Millisecond)<br>  &#125;<br>&#125;<br>poll(<span class="hljs-number">10</span>) <span class="hljs-comment">// 是几秒钟还是几毫秒？</span><br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">poll</span><span class="hljs-params">(delay time.Duration)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    time.Sleep(delay)<br>  &#125;<br>&#125;<br>poll(<span class="hljs-number">10</span>*time.Second)<br></code></pre></td></tr></table></figure></li><li><p><strong>错误类型</strong></p><p>使用 <a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 表示带有静态字符串的错误。 如果调用者需要匹配并处理此错误，则将此错误导出为变量以支持将其与 <code>errors.Is</code> 匹配。</p><p><strong>无错误匹配</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// package foo</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;could not open&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// package bar</span><br><br><span class="hljs-keyword">if</span> err := foo.Open(); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-comment">// Can&#x27;t handle the error.</span><br>  <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown error&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有错误匹配</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// package foo</span><br><br><span class="hljs-keyword">var</span> ErrCouldNotOpen = errors.New(<span class="hljs-string">&quot;could not open&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">return</span> ErrCouldNotOpen<br>&#125;<br><br><span class="hljs-comment">// package bar</span><br><br><span class="hljs-keyword">if</span> err := foo.Open(); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">if</span> errors.Is(err, foo.ErrCouldNotOpen) &#123;<br>    <span class="hljs-comment">// handle the error</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown error&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于动态字符串的错误， 如果调用者不需要匹配它，则使用 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a>， 如果调用者确实需要匹配它，则自定义 <code>error</code>。</p><p><strong>无错误匹配</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// package foo</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">(file <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;file %q not found&quot;</span>, file)<br>&#125;<br><br><span class="hljs-comment">// package bar</span><br><br><span class="hljs-keyword">if</span> err := foo.Open(<span class="hljs-string">&quot;testfile.txt&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-comment">// Can&#x27;t handle the error.</span><br>  <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown error&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有错误匹配</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// package foo</span><br><br><span class="hljs-keyword">type</span> NotFoundError <span class="hljs-keyword">struct</span> &#123;<br>  File <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *NotFoundError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>  <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;file %q not found&quot;</span>, e.File)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">(file <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;NotFoundError&#123;File: file&#125;<br>&#125;<br><br><br><span class="hljs-comment">// package bar</span><br><br><span class="hljs-keyword">if</span> err := foo.Open(<span class="hljs-string">&quot;testfile.txt&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">var</span> notFound *NotFoundError<br>  <span class="hljs-keyword">if</span> errors.As(err, &amp;notFound) &#123;<br>    <span class="hljs-comment">// handle the error</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown error&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>初始化切片和map时指定容量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]T, length, capacity)<br><span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[T1]T2, hint)<br></code></pre></td></tr></table></figure><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt; b.N; n++ &#123;<br>  data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; size; k++&#123;<br>    data = <span class="hljs-built_in">append</span>(data, k)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">BenchmarkBad-4    100000000    2.48s<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt; b.N; n++ &#123;<br>  data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, size)<br>  <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; size; k++&#123;<br>    data = <span class="hljs-built_in">append</span>(data, k)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">BenchmarkBad-4    100000000    2.48s<br></code></pre></td></tr></table></figure><p><strong>同理：使用map的时候也应该指定容量，减少动态扩容，导致的开销</strong></p></li><li><p><strong>在序列化结构中使用字段标记</strong></p><p>任何序列化到JSON、YAML、， 或其他支持基于标记的字段命名的格式应使用相关标记进行注释。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stock <span class="hljs-keyword">struct</span> &#123;<br>  Price <span class="hljs-type">int</span><br>  Name  <span class="hljs-type">string</span><br>&#125;<br>bytes, err := json.Marshal(Stock&#123;<br>  Price: <span class="hljs-number">137</span>,<br>  Name:  <span class="hljs-string">&quot;UBER&quot;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stock <span class="hljs-keyword">struct</span> &#123;<br>  Price <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;price&quot;`</span><br>  Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>  <span class="hljs-comment">// Safe to rename Name to Symbol.</span><br>&#125;<br>bytes, err := json.Marshal(Stock&#123;<br>  Price: <span class="hljs-number">137</span>,<br>  Name:  <span class="hljs-string">&quot;UBER&quot;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>优先使用strconv而不是fmt</strong></p><p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>  s := fmt.Sprint(rand.Int())<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>  s := strconv.Itoa(rand.Int())<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>避免字符串到字节的转换</strong></p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>  w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello world&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">data := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello world&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>  w.Write(data)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>避免过长的行</strong></p></li><li><p><strong>相似的声明放在一起</strong></p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br><br><span class="hljs-keyword">type</span> Area <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Volume <span class="hljs-type">float64</span><br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>  a = <span class="hljs-number">1</span><br>  b = <span class="hljs-number">2</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>  a = <span class="hljs-number">1</span><br>  b = <span class="hljs-number">2</span><br>)<br><br><span class="hljs-keyword">type</span> (<br>  Area <span class="hljs-type">float64</span><br>  Volume <span class="hljs-type">float64</span><br>)<br></code></pre></td></tr></table></figure></li><li><p><strong>包名命名规范</strong></p><p>当命名包时，请按下面规则选择一个名称：</p><ul><li>全部小写。没有大写或下划线。</li><li>大多数使用命名导入的情况下，不需要重命名。</li><li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li><li>不用复数。例如<code>net/url</code>，而不是<code>net/urls</code>。</li><li>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。</li></ul><p>另请参阅 <a href="https://blog.golang.org/package-names">Go 包命名规则</a> 和 <a href="https://rakyll.org/style-packages/">Go 包样式指南</a>.</p></li><li><p><strong>函数名命名规范</strong></p><p>我们遵循 Go 社区关于使用 <a href="https://golang.org/doc/effective_go.html#mixed-caps">MixedCaps 作为函数名</a> 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：<code>TestMyFunction_WhatIsBeingTested</code>.</p></li><li><p><strong>函数分组与顺序</strong></p><ul><li>函数应按粗略的调用顺序排序。</li><li>同一文件中的函数应按接收者分组。</li></ul><p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。</p><p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>&#x2F;<code>NewXYZ()</code></p><p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *something)</span></span> Cost() &#123;<br>  <span class="hljs-keyword">return</span> calcCost(s.weights)<br>&#125;<br><br><span class="hljs-keyword">type</span> something <span class="hljs-keyword">struct</span>&#123; ... &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcCost</span><span class="hljs-params">(n []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;...&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *something)</span></span> Stop() &#123;...&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSomething</span><span class="hljs-params">()</span></span> *something &#123;<br>    <span class="hljs-keyword">return</span> &amp;something&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> something <span class="hljs-keyword">struct</span>&#123; ... &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSomething</span><span class="hljs-params">()</span></span> *something &#123;<br>    <span class="hljs-keyword">return</span> &amp;something&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *something)</span></span> Cost() &#123;<br>  <span class="hljs-keyword">return</span> calcCost(s.weights)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *something)</span></span> Stop() &#123;...&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcCost</span><span class="hljs-params">(n []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;...&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>减少嵌套</strong></p><p>代码应通过尽可能先处理错误情况&#x2F;特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> data &#123;<br>  <span class="hljs-keyword">if</span> v.F1 == <span class="hljs-number">1</span> &#123;<br>    v = process(v)<br>    <span class="hljs-keyword">if</span> err := v.Call(); err == <span class="hljs-literal">nil</span> &#123;<br>      v.Send()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> err<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    log.Printf(<span class="hljs-string">&quot;Invalid v: %v&quot;</span>, v)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> data &#123;<br>  <span class="hljs-keyword">if</span> v.F1 != <span class="hljs-number">1</span> &#123;<br>    log.Printf(<span class="hljs-string">&quot;Invalid v: %v&quot;</span>, v)<br>    <span class="hljs-keyword">continue</span><br>  &#125;<br><br>  v = process(v)<br>  <span class="hljs-keyword">if</span> err := v.Call(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br>  v.Send()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>不必要的else</strong></p><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br><span class="hljs-keyword">if</span> b &#123;<br>  a = <span class="hljs-number">100</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  a = <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">10</span><br><span class="hljs-keyword">if</span> b &#123;<br>  a = <span class="hljs-number">100</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>nil是一个有效的slice</strong></p><p><code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，您不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> x == <span class="hljs-string">&quot;&quot;</span> &#123;<br>  <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> x == <span class="hljs-string">&quot;&quot;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> s == <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">nums := []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-comment">// or, nums := make([]int)</span><br><br><span class="hljs-keyword">if</span> add1 &#123;<br>  nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> add2 &#123;<br>  nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums []<span class="hljs-type">int</span><br><br><span class="hljs-keyword">if</span> add1 &#123;<br>  nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> add2 &#123;<br>  nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>记住，虽然 nil 切片是有效的切片，但它不等于长度为 0 的切片（一个为 nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p></li><li><p><strong>缩小变量作用域</strong></p><p>如果有可能，尽量缩小变量作用范围。除非它与 减少嵌套的规则冲突。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">err := os.WriteFile(name, data, <span class="hljs-number">0644</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br> <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := os.WriteFile(name, data, <span class="hljs-number">0644</span>); err != <span class="hljs-literal">nil</span> &#123;<br> <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p><p><strong>Bad</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> data, err := os.ReadFile(name); err == <span class="hljs-literal">nil</span> &#123;<br>  err = cfg.Decode(data)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br><br>  fmt.Println(cfg)<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Good</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := os.ReadFile(name)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> err := cfg.Decode(data); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> err<br>&#125;<br><br>fmt.Println(cfg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure></li></ol><p>参考：</p><ol><li><a href="https://learnku.com/go/wikis/38426">https://learnku.com/go/wikis/38426</a></li><li>《Go 语言编码规范》中文翻译地址：<a href="https://github.com/xxjwxc/uber_go_guide_cn">https://github.com/xxjwxc/uber_go_guide_cn</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编码规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang pprof性能分析</title>
    <link href="/2024/01/01/Golang-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2024/01/01/Golang-pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://blog.wolfogre.com/posts/go-ppof-practice/#%E6%8E%92%E6%9F%A5-cpu-%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98">https://blog.wolfogre.com/posts/go-ppof-practice/#%E6%8E%92%E6%9F%A5-cpu-%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>pprof</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《程序员的38堂成长课》读书笔记</title>
    <link href="/2023/12/25/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8438%E5%A0%82%E6%88%90%E9%95%BF%E8%AF%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/25/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8438%E5%A0%82%E6%88%90%E9%95%BF%E8%AF%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《10x程序员工作法》课程笔记</title>
    <link href="/2023/12/25/%E3%80%8A10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95%E3%80%8B%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/25/%E3%80%8A10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95%E3%80%8B%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>课程学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《可复制的沟通力》读书笔记</title>
    <link href="/2023/12/25/%E3%80%8A%E5%8F%AF%E5%A4%8D%E5%88%B6%E7%9A%84%E6%B2%9F%E9%80%9A%E5%8A%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/25/%E3%80%8A%E5%8F%AF%E5%A4%8D%E5%88%B6%E7%9A%84%E6%B2%9F%E9%80%9A%E5%8A%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>沟通力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高效沟通的技巧与方法</title>
    <link href="/2023/12/25/%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%E7%9A%84%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <url>/2023/12/25/%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%E7%9A%84%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="https://www.hrloo.com/news/110190.html">https://www.hrloo.com/news/110190.html</a></li><li><a href="https://www.zhihu.com/tardis/zm/art/292931625?source_id=1003">https://www.zhihu.com/tardis/zm/art/292931625?source_id=1003</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何写出一篇好的技术方案</title>
    <link href="/2023/12/23/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    <url>/2023/12/23/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="写技术方案的意义"><a href="#写技术方案的意义" class="headerlink" title="写技术方案的意义"></a>写技术方案的意义</h2><p>写技术方案根本目的是提高研发效率和质量，具体体现在以下方面：</p><h3 id="提高沟通效率"><a href="#提高沟通效率" class="headerlink" title="提高沟通效率"></a>提高沟通效率</h3><ol><li>产品：验证技术方案是否能够 match 上产品方案</li><li>测试：验证技术方案对测试方案是否有足够 &amp; 准确的输入</li><li>同事 &amp; leader：参与技术方案评审，验证技术方案的合理性</li><li>新人(不单单指新同学也指新接触这一块的同学)：拿到技术方案可以很快对某一块的事情熟悉起来</li></ol><h3 id="提高开发效率和质量"><a href="#提高开发效率和质量" class="headerlink" title="提高开发效率和质量"></a>提高开发效率和质量</h3><p>对于开发同学，通过写技术方案，把需求和实现提前梳理一遍，减少等到编码阶段才发现前期考虑不全导致返工的情况；并且写好技术方案再编码，使得编码时思维更加清晰，提高编码效率和质量。</p><h2 id="什么样的技术方案是一个好的技术方案"><a href="#什么样的技术方案是一个好的技术方案" class="headerlink" title="什么样的技术方案是一个好的技术方案"></a>什么样的技术方案是一个好的技术方案</h2><p>技术方案是指导具体开发工作的，可以分别从开发的事前、事中、事后来讨论这个问题。</p><h3 id="事前"><a href="#事前" class="headerlink" title="事前"></a>事前</h3><ol><li>明确的目标：整个技术方案要达成什么目的</li><li>低沟通成本：产品测试能从技术方案上获取足够的输入，不需要反复找你确认</li><li>技术选型思考：为什么要这么做?和业内方案相比有什么好处和坏处，如何权衡的</li></ol><h3 id="事中"><a href="#事中" class="headerlink" title="事中"></a>事中</h3><ol><li>少调整：尽可能少的技术方案需要调整， 否则无法完成开发任务</li></ol><h3 id="事后"><a href="#事后" class="headerlink" title="事后"></a>事后</h3><ol><li>少bug：尽可能少的 bug 或者遗漏</li><li>可扩展 &amp; 可复用：相对简单的改动就能支持新增需求，类似场景可复用不需要重复开发</li></ol><p>一篇好的技术方案可以贯穿整个研发的生命周期，并且能起到很好的指导意义，就如同写小说之前作者必须出一个大纲的逻辑是一致的。</p><h2 id="如何写好一篇好的技术方案"><a href="#如何写好一篇好的技术方案" class="headerlink" title="如何写好一篇好的技术方案"></a>如何写好一篇好的技术方案</h2><p>下面列举写出一篇好的技术方案，应该做到的一些点。</p><h2 id="清晰的目标"><a href="#清晰的目标" class="headerlink" title="清晰的目标"></a>清晰的目标</h2><p>满足需求</p><p>可实施</p><p>概要设计</p><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><p>俗话说得好，一图胜千言。在输出技术方案时，除了文字描述外，适当的图表和图像能够更加直观地表达设计意图和操作流程，有助于别人理解方案内容。因此，在制作技术方案时，我们应该注重使用图表和图像来辅助说明，以提升沟通效率和信息传递的准确性。</p><ol><li><p>架构图</p><p>从架构图可以看出模块划分和层次结构以及外部依赖。</p></li><li><p>模型设计</p><p>数据模型设计，E-R 图是必不可少的。我们的服务如果需要做数据持久化，就需要有DB来存储数据。E-R图可以很直观的看出表的结构，每张表的字段设计和表与表之间的关联关系等。</p></li><li><p>时序图</p></li><li><p>流程图</p></li></ol><h3 id="技术选型分析"><a href="#技术选型分析" class="headerlink" title="技术选型分析"></a>技术选型分析</h3><p>需求拆分</p><p>方案的思考</p><p>调研，业界通用的做法</p><p>存储选型，mysql？mongoDB？</p><p>语言选型？</p><h3 id="安全生产"><a href="#安全生产" class="headerlink" title="安全生产"></a>安全生产</h3><p>一图胜千言</p><p>参考</p><ol><li><a href="https://www.51cto.com/article/710330.html">https://www.51cto.com/article/710330.html</a></li><li><a href="https://www.jianshu.com/p/13503e2e7195">https://www.jianshu.com/p/13503e2e7195</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>方案设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《金字塔原理》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《设计模式之禅》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《大话设计模式》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《SQL必知会》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8ASQL%E5%BF%85%E7%9F%A5%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8ASQL%E5%BF%85%E7%9F%A5%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《代码整洁知道：程序员的职业素养》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E7%9F%A5%E9%81%93%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E7%9F%A5%E9%81%93%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《高性能MySQL（第3版）》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《操作系统导论》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《MySQL技术内幕InnoDB存储引擎》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>InnoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Redis设计与实现》读书笔记</title>
    <link href="/2023/12/21/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/21/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《微服务设计》读书笔记</title>
    <link href="/2023/12/20/%E3%80%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/%E3%80%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go-zero学习笔记</title>
    <link href="/2023/12/20/go-zero%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/go-zero%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务及实现方案</title>
    <link href="/2023/12/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <url>/2023/12/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="https://pdai.tech/md/arch/arch-z-transection.html">https://pdai.tech/md/arch/arch-z-transection.html</a></li><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">https://xiaomi-info.github.io/2020/01/02/distributed-transaction/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>方案设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方案设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ学习笔记</title>
    <link href="/2023/12/20/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch学习笔记</title>
    <link href="/2023/12/20/ElasticSearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/ElasticSearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka学习笔记</title>
    <link href="/2023/12/20/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang编码规范和建议</title>
    <link href="/2023/12/20/Golang%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E5%92%8C%E5%BB%BA%E8%AE%AE/"/>
    <url>/2023/12/20/Golang%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E5%92%8C%E5%BB%BA%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记</title>
    <link href="/2023/12/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="/2023/12/20/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB学习笔记</title>
    <link href="/2023/12/20/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/20/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令和使用规范</title>
    <link href="/2023/12/19/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <url>/2023/12/19/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Git常用命令列表"><a href="#一、Git常用命令列表" class="headerlink" title="一、Git常用命令列表"></a>一、Git常用命令列表</h2><ol><li><p><code>git config</code>： 设置 Git 配置值</p><p>设置 Git 用户名</p><p>创建 Git 别名</p><p>设置 Git 编辑器</p><p>列出 Git 配置属性</p></li><li><p><code>git init</code> ： 创建一个新的 Git 仓库</p></li><li><p><code>git clone</code> ： 克隆一个 Git 仓库</p></li><li><p><code>git add</code>： 添加文件内容到暂存区</p><p>添加单个文件</p><p>添加多个文件</p><p>添加所有文件</p><p>添加删除和修改的文件</p><p>在当前目录中添加文件</p><p>添加具有特定文件扩展名的文件</p></li><li><p><code>git rm -f</code>： 从 Git 存储库中删除文件</p><p>删除单个文件</p><p>删除多个文件</p><p>删除目录</p></li><li><p><code>git mv</code>： 移动或重命名 Git 存储库文件</p><p>重命名项目文件</p><p>移动项目文件</p></li><li><p><code>git commit</code>： 将更改保存到 Git 存储库</p><p>添加新提交</p><p>修复先前的提交</p><p>提交修改后的文件</p></li><li><p><code>git branch</code>： 列出、创建或删除分支</p><p>列出存储库分支</p><p>创建一个新分支</p><p>删除现有分支</p></li><li><p><code>git status</code> ： 显示存储库和暂存区的状态</p></li><li><p><code>git diff</code>： 跟踪文件中的更改</p><p>显示未暂存但已修改的更改</p><p>显示分阶段但未提交的更改</p><p>显示两个分支之间的差异</p><p>比较已提交与未提交的文件</p><p>比较两个特定文件版本</p></li><li><p><code>git log</code>： 显示提交历史</p><p>显示提交历史</p><p>过滤 Git 日志</p></li><li><p><code>git checkout</code>： 在分支之间切换</p><p>切换到现有分支</p><p>切换到新分支</p><p>恢复文件的先前版本</p></li><li><p><code>git merge</code>：合并 Git 分支</p></li><li><p><code>git fetch</code> ： 下载远程 Git 存储库</p></li><li><p><code>git pull</code>：下载并合并 Git 仓库</p></li><li><p><code>git push</code>：使用本地提交更新远程分支</p></li><li><p><code>git rebase</code> ： 更改一系列提交</p></li><li><p><code>git revert</code> ： 还原现有提交</p></li><li><p><code>git reset</code> ： 还原 Git 存储库提交</p></li><li><p><code>git stash</code> ： 在本地保存未提交的更改</p></li><li><p><code>git reflog</code> ： 跟踪分支的变化</p></li></ol><h2 id="二、Git常用命令用法详情"><a href="#二、Git常用命令用法详情" class="headerlink" title="二、Git常用命令用法详情"></a>二、Git常用命令用法详情</h2><ol><li><p><strong><code>git config</code>： 设置 Git 配置值</strong></p><p><strong>设置 Git 用户名</strong></p><p>要全局设置与git存储库关联的用户名和电子邮件地址，请执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;your_username&quot;</span> <br>git config --global user.email <span class="hljs-string">&quot;your_email_address&quot;</span><br></code></pre></td></tr></table></figure><p>也可以执行<code>vi ~/.gitconfig</code>，修改全局的gitconfig配置文件，在配置文件加入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[user]<br>        name = your_username<br>        email = your_email_address<br></code></pre></td></tr></table></figure><p>要在项目基础上（不是全局）设置存储库的用户名和密码，请执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config user.name <span class="hljs-string">&quot;your_username&quot;</span><br>git config user.email <span class="hljs-string">&quot;your_email_address&quot;</span><br></code></pre></td></tr></table></figure><p>也可以在对应项目根目录下执行<code>vi .git/config</code>修改项目的git配置文件，在配置文件加入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[user]<br>        name = your_username<br>        email = your_email_address<br></code></pre></td></tr></table></figure><p><strong>创建Git别名</strong></p><p>我们还可以使用git config命令创建 Git 别名，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global alias.s status <br></code></pre></td></tr></table></figure><p><strong>设置 Git 编辑器</strong></p><p>git config命令也非常适合用于在编写或编辑提交消息时设置用户的首选文本编辑器：将“ editor-name ”替换为您正在使用的文本编辑器的名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.editor <span class="hljs-string">&quot;editor-name&quot;</span> [Globally]<br>git config core.editor <span class="hljs-string">&quot;editor-name&quot;</span>          [Project Basis]<br></code></pre></td></tr></table></figure><p><strong>列出 Git 配置属性</strong></p><p>此外，可以使用以下git config命令查看活动存储库的当前配置选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git init</code> ： 创建一个新的 Git 仓库</strong></p><p>git init命令可以在本地文件系统的当前目录上初始化 Git 存储库。它还创建一个’.git’子目录（隐藏目录），其中包含必要的存储库文件，如索引和对象数据库文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init <br></code></pre></td></tr></table></figure></li><li><p><strong><code>git clone</code>：克隆一个 Git 仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [URL]<br></code></pre></td></tr></table></figure><p><strong>下载指定目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [URL] [<span class="hljs-built_in">dir</span>]<br></code></pre></td></tr></table></figure><p>下载指定分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b [branch] [URL]<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git add</code>： 添加文件内容到暂存区</strong></p><p><strong>添加文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add test.go<br></code></pre></td></tr></table></figure><p><strong>添加多个文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add test1.go test2.go<br></code></pre></td></tr></table></figure><p><strong>添加当前目录下的全部文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git rm -f</code>：从 Git 存储库中删除文件</strong></p><p>git rm命令可用于从 git 存储库中删除不需要的项目文件。该-f标志强制删除带有阻止正常删除限制的文件。它还会暂存已删除的文件以供提交，以便托管存储库知道已删除的项目文件。</p><p><strong>删除单个文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> -f file4.txt<br></code></pre></td></tr></table></figure><p><strong>删除多个文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">rm</span> file1.txt file2.php file3.py file4<br></code></pre></td></tr></table></figure><p><strong>删除目录</strong></p><p>我们还可以使用-r标志递归地删除项目目录及其内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">rm</span> -f -r directory_name<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git mv</code>：移动或重命名git仓库文件</strong></p><p>git mv命令移动并重命名 Git 存储库文件。来自这些移动和重命名操作的更改也被暂存以提交到存储库。</p><p><strong>重命名项目文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">mv</span> old-name.txt new-name.txt<br></code></pre></td></tr></table></figure><p><strong>移动项目文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ba">$ git mv file3.txt beta/file3.txt<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git commit</code>：将更改保存到Git仓库</strong></p><p><strong>添加提交</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;注释&quot;</span><br></code></pre></td></tr></table></figure><p><strong>修改上一个提交的注释</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit --amend -m <span class="hljs-string">&quot;新的注释&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>git branch</code>：列出、创建或删除分支</strong></p><p><strong>列出当前仓库本地的所有分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p><strong>创建新的分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch 分支名<br></code></pre></td></tr></table></figure><p><strong>删除分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d 分支名<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git status</code>：显示存储库和暂存区的状态</strong></p><p>显示存储库和暂存区的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git diff</code>：跟踪文件中的更改</strong></p><p><strong>显示未暂存但已修改的更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff<br></code></pre></td></tr></table></figure><p><strong>显示暂存但未提交的更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff --staged <br></code></pre></td></tr></table></figure><p><strong>显示两个分支的差异</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff Branch_1...Branch_2<br></code></pre></td></tr></table></figure><p><strong>显示指定分支和当前分支代码的差异</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff branch-name<br></code></pre></td></tr></table></figure><p><strong>比较已提交和未提交的文件状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff file-name<br></code></pre></td></tr></table></figure><p><strong>比较两个特定的文件版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff commit-id-1 commit-id-2 file-name<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git log</code>：显示提交历史</strong></p><p><strong>显示提交历史</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><strong>按作者过滤</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --author=author_name<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git checkout</code>：在分支之间切换</strong></p><p><strong>切换到指定分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout 分支名<br></code></pre></td></tr></table></figure><p><strong>创建并切换到新分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b 新分支名<br></code></pre></td></tr></table></figure><p><strong>恢复文件到指定版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout HEAD -- file3.txt<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git merge</code>：合并两个分支</strong></p><p>合并master分支到当前分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge master<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git fetch</code>：下载远程Git存储库</strong></p><p><strong>git fetch</strong>命令下载远程存储库的最新版本并更新此存储库的等效本地副本。它在本地存储检索到的引用、文件和提交，而不将它们与本地存储库合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git pull</code>：下载并合并Git仓库</strong></p><p>我们使用<strong>git pull</strong>命令下载远程存储库的最新版本，然后将其与等效的本地存储库副本合并。<strong>git pull</strong>命令结合了<strong>git fetch</strong>和<strong>git merge</strong>命令的功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git push</code>：使用本地提交更新到远程分支</strong></p><p><strong>git push</strong>命令使远程存储库分支能够接收本地分支提交。当本地存储库领先于（更多更新）远程存储库时，我们使用此命令。它使远程存储库与本地存储库中的新更改保持同步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git rebase</code>：更改一系列提交</strong></p><p><strong>git rebase</strong>命令将 branchA 的更改<strong>集成</strong>到branchB<strong>中</strong>。它采用当前分支的本地提交并在更新的代码版本之上重播它们，而不是采用“ <strong>git merge</strong> ”命令方法来创建新提交并合并更改。</p><p>考虑以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase branch1<br></code></pre></td></tr></table></figure><p>在这里，当前分支的提交在<strong>branch1 的</strong>更新代码版本之上重新应用。只有在没有发生分支冲突时，rebase 操作才会完成。否则，您需要先解决冲突。</p><p>作为<strong>git merge</strong>命令的替代方法，<strong>git rebase</strong>创建了一个更易于理解和解释的线性提交历史记录。</p><p>虽然<strong>git merge</strong>是非破坏性的，但<strong>git rebase</strong>有潜在的缺陷。它通过生成新的提交来重写项目历史。</p><p>考虑以下 git rebase 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br>git rebase loco<br></code></pre></td></tr></table></figure><p>上面的命令将整个<strong>主</strong>分支移动到一个<strong>loco</strong>分支的顶端。所有<strong>本地</strong>分支提交也被合并。</p></li><li><p><strong><code>git revert</code>：还原现有提交</strong></p><p>当需要恢复现有&#x2F;以前的提交时，git revert命令很有用。它撤消以前&#x2F;现有的 Git 存储库更改。它为还原的提交更改创建一个新的提交，并使存储库处于干净状态，就好像这些已删除更改的实现从未发生过一样。</p><p><strong>git revert</strong>命令的语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert &lt;commit_hash&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git reset</code>：还原 Git 存储库提交</strong></p><p><strong>git reset</strong>命令撤消 Git 存储库提交。撤消的提交可以从存储库中永久删除，因此可以使用此命令丢弃它们。它还将存储库重置为先前的状态，并移至分支指针的先前提交</p><p>要取消暂存特定项目文件并保留当前工作目录更改，请执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset [file_name]<br></code></pre></td></tr></table></figure><p>要清除暂存区并根据特定提交重写工作树，请执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard [commit_hash] <br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>git reset</code>会永久删除提交记录，不可找回</p></li><li><p><strong><code>git stash</code>：在本地保存未提交的更改</strong></p><p><strong>git stash</strong>命令临时搁置项目更改，如跟踪和修改的文件，而用户在返回以重新应用这些项目更改之前处理其他内容（例如切换分支）。这些临时保存的更改不会提交 ( <strong>git commit</strong> )。</p><p><strong>要保存已修改和暂存的项目更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br></code></pre></td></tr></table></figure></li><li><p><strong><code>git relog</code>：跟踪分支的变化</strong></p><p><strong>git reflog</strong>命令在处理参考日志时很有用。它在显示 Git 存储库中的更改历史记录时引用本地分支。此命令的输出需要提交哈希、执行的操作和与更改相关的分支名称。</p><p>对于最近的还原、拉取、提交等的 HEAD reflog，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog<br></code></pre></td></tr></table></figure></li></ol><h2 id="三、Git命令使用规范和建议"><a href="#三、Git命令使用规范和建议" class="headerlink" title="三、Git命令使用规范和建议"></a>三、Git命令使用规范和建议</h2><ol><li><p>回滚提交时，用<code>git revert</code>代替<code>git reset</code></p><p>git reset命令撤消 Git 存储库提交。撤消的提交可以从存储库中永久删除，这个命令的好处是提交会被永久删除，坏处也是提交会被永久删除，后续如果我们要回滚到对应的提交就办法做到了。如果我们有需要回滚到指定的提交，建议使用<code>git revert</code>，git revert不会删除任何提交记录，这样子能保证每一次的修改和提交都有记录可查。</p></li></ol><p>参考：</p><ol><li><a href="https://bbs.huaweicloud.com/blogs/388474">https://bbs.huaweicloud.com/blogs/388474</a></li><li><a href="https://cloud.tencent.com/developer/article/1910779">https://cloud.tencent.com/developer/article/1910779</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法Golang实现</title>
    <link href="/2023/12/18/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Golang%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/12/18/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Golang%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈DFS和BFS</title>
    <link href="/2023/12/18/%E6%B5%85%E8%B0%88DFS%E5%92%8CBFS/"/>
    <url>/2023/12/18/%E6%B5%85%E8%B0%88DFS%E5%92%8CBFS/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈动态规划</title>
    <link href="/2023/12/18/%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/12/18/%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎么绘制时序图</title>
    <link href="/2023/12/16/%E6%80%8E%E4%B9%88%E7%BB%98%E5%88%B6%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    <url>/2023/12/16/%E6%80%8E%E4%B9%88%E7%BB%98%E5%88%B6%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是时序图"><a href="#一、什么是时序图" class="headerlink" title="一、什么是时序图"></a>一、什么是时序图</h2><p>时序图(Sequence Diagram)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</p><h2 id="二、绘制时序图常用的工具"><a href="#二、绘制时序图常用的工具" class="headerlink" title="二、绘制时序图常用的工具"></a>二、绘制时序图常用的工具</h2><p>绘制时序图常用的工具有：</p><ol><li><p><a href="https://www.processon.com/">processon</a>，拖拽图形作图。</p><p>优点：易上手，自由度较高。</p><p>缺点：作图效率低。</p></li><li><p>MarkDown，写代码作图。</p><p>优点：会自动按照时序图规则调整图形和文字位置，作图效率高。</p><p>缺点：需要学习作图语法，有一定学习成本。</p></li></ol><h2 id="三、时序图组成元素"><a href="#三、时序图组成元素" class="headerlink" title="三、时序图组成元素"></a>三、时序图组成元素</h2><p>时序图中包括如下5个元素：角色、对象、生命线、控制焦点、消息。</p><ol><li><p>角色（Actor）</p><p>系统角色，可以是人、机器、其他系统、子系统</p></li><li><p>对象（Object）</p><p>（1）对象的三种命名方式</p><ul><li>第一种方式包括对象名和类名，例如：直播课时:课时，在时序图中，用“对象：类”表示；</li><li>第二种方式只显示类名，即表示它是一个匿名对象，例如： :课程；在时序图中，用“：类”表示；</li><li>第三种方式只显示对象名不显示类名，例如：讲师；在时序图中，用“对象”表示。</li></ul><p>（2）命名方式的选择</p><p>三种命名方式均可，哪种最容易让阅读该时序图的人理解，就选择哪种。</p><p>（3）对象的排列顺序</p><p>对象的左右顺序并不重要，但是为了作图清晰整洁，通常应遵循以下两个原则：把交互频繁的对象尽可能的靠拢；2.把初始化整个交互活动的对象放置在最左端。</p></li><li><p>生命线（Lifeline）</p><p>在时序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间。</p></li><li><p>控制焦点（Focus of Control）</p><p>又称为激活期，表示时间段的符号，在这个时间段内对象将执行相应的操作。它可以被理解成C语言语义中一对花括号{ }中的内容；用小矩形表示。</p></li><li><p>消息（Message）</p><p>消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）。</p><ul><li>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义；</li><li>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。</li><li>返回消息表示从过程调用返回。</li></ul></li></ol><h2 id="四、时序图语法"><a href="#四、时序图语法" class="headerlink" title="四、时序图语法"></a>四、时序图语法</h2><h2 id="五、时序图例子学习"><a href="#五、时序图例子学习" class="headerlink" title="五、时序图例子学习"></a>五、时序图例子学习</h2><pre><code class=" mermaid">sequenceDiagramClient-&gt;&gt;Gateway : 发送JSON RPC请求Gateway--&gt;&gt;Client : 把JSON RPC响应发送给客户端</code></pre><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><ol><li><a href="https://www.woshipm.com/ucd/607593.html">https://www.woshipm.com/ucd/607593.html</a></li><li><a href="https://juejin.cn/post/7038144693867118629">https://juejin.cn/post/7038144693867118629</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>画图</tag>
      
      <tag>时序图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式锁的实现</title>
    <link href="/2023/12/16/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/12/16/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/asd051377305/article/details/108384490">https://blog.csdn.net/asd051377305/article/details/108384490</a></p>]]></content>
    
    
    <categories>
      
      <category>方案设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>分布式</tag>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决GitHub打不开和访问慢等问题</title>
    <link href="/2023/12/15/GitHub%E6%89%93%E4%B8%8D%E5%BC%80%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2023/12/15/GitHub%E6%89%93%E4%B8%8D%E5%BC%80%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>在家里的网络，GitHub经常打不开或者响应时间很长，这里分享一下如何解决GitHub访问慢的问题。</p><h3 id="二、原因"><a href="#二、原因" class="headerlink" title="二、原因"></a>二、原因</h3><p>GitHub访问慢本质上是我们在访问GitHub网页的时候无法通过github.com的二级域名进行域名解析。</p><h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><p>手动修改设备的hosts文件，将该域名和IP的映射关系添加到设备的hosts文件中，在访问地址时会优先通过Hosts文件进行域名解析。</p><h3 id="四、解决步骤"><a href="#四、解决步骤" class="headerlink" title="四、解决步骤"></a>四、解决步骤</h3><ol><li>找到github.com域名对应的IP地址，输入网址：<a href="https://tool.chinaz.com/dns/?type=1">站长工具Dns查询</a>找出最快的IP地址</li></ol><p><img src="/2023/12/15/GitHub%E6%89%93%E4%B8%8D%E5%BC%80%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/img_1.png" alt="输入域名"><br><img src="/2023/12/15/GitHub%E6%89%93%E4%B8%8D%E5%BC%80%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/img.png" alt="选取ip"></p><ol start="2"><li>修改hosts，把最快的ip填入hosts</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><ol start="3"><li>再次执行命令刷新DNS</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo killall -HUP mDNSResponder;say DNS cache has been flushed<br></code></pre></td></tr></table></figure><ol start="4"><li>再次打开<a href="https://github.com/">GitHub</a>,可以访问了，大功告成</li></ol>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>借助Hexo+GitHub Pages零成本搭建个人博客</title>
    <link href="/2023/12/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/12/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="一、前期准备工作"><a href="#一、前期准备工作" class="headerlink" title="一、前期准备工作"></a>一、前期准备工作</h2><p>注：我的电脑是mac，后面的全部指令都是mac上操作的</p><ol><li>申请GitHub账号</li><li>本地安装Git</li><li>本地NodeJS<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install node<br></code></pre></td></tr></table></figure></li><li>本地安装Hexo<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li></ol><h2 id="二、用Hexo生成博客项目"><a href="#二、用Hexo生成博客项目" class="headerlink" title="二、用Hexo生成博客项目"></a>二、用Hexo生成博客项目</h2><ol><li>初始化博客<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init my-blog<br><span class="hljs-built_in">cd</span> my-blog<br>npm install<br></code></pre></td></tr></table></figure></li><li>生成网页文件&amp;本地启动<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate <span class="hljs-comment"># 生成页面，此命令可以简写为 `hexo g`</span><br>hexo server <span class="hljs-comment"># 本地启动，可简写为 `hexo s`</span><br></code></pre></td></tr></table></figure>通过 hexo g 生成的页面文件在项目 public 目录下;<br>使用 hexo clean 命令可以清理生成的页面文件。当配置未生效时，建议执行清理命令。</li><li>本地访问<br>浏览器访问：<a href="http://localhost:4000/">http://localhost:4000/</a> 会看到一个比较简陋的页面。没关系，接下来介绍如何更换主题。</li></ol><h2 id="三、安装-配置主题"><a href="#三、安装-配置主题" class="headerlink" title="三、安装&amp;配置主题"></a>三、安装&amp;配置主题</h2><p>官方提供了数百种主题任君选择，可以根据个人喜好更换，具体可以点击 (<a href="https://hexo.io/themes/">https://hexo.io/themes/</a>) 查看。<br>本文将主要介绍 Fluid 主题的安装与配置。</p><ol><li>安装 Fluid 主题<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure>在博客根路径下创建 _config.fluid.yml 文件，并将主题的 .&#x2F;node_modules&#x2F;hexo-theme-fluid&#x2F;_config.yml 文件内容复制过去</li><li>指定主题<br>将如下修改应用到 Hexo 博客目录中的 _config.yml:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: fluid  <span class="hljs-comment"># 指定主题</span><br>language: zh-CN  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure></li><li>创建「关于页」<br>首次使用主题的「关于页」需要手动创建。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure>创建成功后修改 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。修改后的文件示例如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-string">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-string">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure>需要注意的是， layout: about 必须存在，并且不能修改成其他值，否则不会显示头像等样式。</li><li>更新 Fluid 主题<br>通过 npm 安装主题的情况，可在博客目录下执行命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm update --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li><li>本地启动</li></ol><p>  执行如下命令重新生成页面，并启动 Hexo 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp; hexo g &amp; hexo s<br></code></pre></td></tr></table></figure><p>再次通过浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> , 便可以看到页面变得美观多了。</p><h2 id="四、创建文章"><a href="#四、创建文章" class="headerlink" title="四、创建文章"></a>四、创建文章</h2><ol><li>修改 _config.yml 文件。这项配置是为了在生成文章的同时，生成一个同名的资源目录用于存放图片等资源文件。</li></ol><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol start="2"><li>创建文件名为 my-blog-build-remark 文章。</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> my-blog-build-remark<br></code></pre></td></tr></table></figure><ol start="3"><li>设置文章的标题及其他元素信息。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">借助Hexo+GitHub</span> <span class="hljs-string">Pages零成本搭建个人博客</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">&#x27;hexo&#x27;</span>,<span class="hljs-string">&#x27;fluid&#x27;</span>]<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ol start="4"><li>如上命令执行成功后，在 source&#x2F;_posts&#x2F; 目录下生成了一个 Markdown 文件和一个同名的资源目录。<br>在 source&#x2F;_posts&#x2F;my-blog-build-remark 目录中放置一个图片文件 posts-file-tree.png，整体目录结构如下：</li></ol><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dos">$ source/_posts (main)&gt; <span class="hljs-built_in">tree</span><br>.<br>├── hello-world.<span class="hljs-built_in">md</span><br>├── my-blog-build-remark<br>│   └── img.png<br>└── my-blog-build-remark.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><ol start="5"><li>文章中插入图片</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">!<span class="hljs-selector-attr">[图片备注]</span>(./my-blog-build-remark/<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.png</span>)<br></code></pre></td></tr></table></figure><p>文章创建并编辑好之后，就可以通过 <code>hexo g &amp;&amp; hexo s</code> 命令启动服务，并在本地预览文章。</p><h2 id="五、发布GitHub-Pages"><a href="#五、发布GitHub-Pages" class="headerlink" title="五、发布GitHub Pages"></a>五、发布GitHub Pages</h2><ol><li>在GitHub上建立仓库</li><li>token获取<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">登录G<span class="hljs-function"><span class="hljs-title">itHub</span>-&gt;</span>S<span class="hljs-function"><span class="hljs-title">ettings</span>-&gt;</span>D<span class="hljs-function"><span class="hljs-title">eveloper</span> settings-&gt;</span>P<span class="hljs-function"><span class="hljs-title">ersonal</span> access tokens-&gt;</span>T<span class="hljs-function"><span class="hljs-title">okens</span>-&gt;</span>Generate a personal access token<br></code></pre></td></tr></table></figure></li><li>修改站点配置 _config.yml<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> <span class="hljs-params">&lt;repository url&gt;</span> <span class="hljs-meta"># https:<span class="hljs-comment">//github.com/&lt;GitHub用户名&gt;/&lt;GitHub用户名&gt;.github.io.git</span></span><br><span class="hljs-symbol">  branch:</span> [branch]<br><span class="hljs-symbol">  token:</span> [token]<br></code></pre></td></tr></table></figure></li><li>生成站点文件并推送至远程 GitHub 仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp; hexo deploy<br></code></pre></td></tr></table></figure>只需稍等片刻，个人博客站点就会显示在 Github Pages 中。</li></ol><h2 id="六、可能会遇到的问题"><a href="#六、可能会遇到的问题" class="headerlink" title="六、可能会遇到的问题"></a>六、可能会遇到的问题</h2><ol><li>文章中插入图片浏览器显示不出来的解决办法<br><img src="/2023/12/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/img.png" alt="图片显示不出来"><br>上面的错误是因为Hexo缺少处理图片的插件，导致生成的代码用的图片链接是相对路径，如果要让浏览器能够访问图片需要用绝对路径。<br>这里需要下载插件帮助我们处理图片路径问题。安装插件命令如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-filter-image --save<br></code></pre></td></tr></table></figure>安装完重新生成代码就可以了<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo  clean<br>hexo g &amp; hexo s<br></code></pre></td></tr></table></figure></li></ol><h2 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h2><ol><li>Hexo Docs：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></li><li>Hexo Fluid 用户手册：<a href="https://fluid-dev.github.io/hexo-fluid-docs/">https://fluid-dev.github.io/hexo-fluid-docs/</a></li><li><a href="https://xie.infoq.cn/article/ac51ce1f6e9434779c35cbb6c">https://xie.infoq.cn/article/ac51ce1f6e9434779c35cbb6c</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
